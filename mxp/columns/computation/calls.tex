We define several simple constraint systems to simplify the writing of constraints.
\[
	\left\{ \begin{array}{lcl}
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\wcpCallToLt {
			anchorRow = i           ,
			relOffset = \relof      ,
			argOneHi  = \col{a\_hi} ,
			argOneLo  = \col{a\_lo} ,
			argTwoHi  = \col{b\_hi} ,
			argTwoLo  = \col{b\_lo} ,
		} & \define &
		\left\{ \begin{array}{lcl}
			\mxpComputationWcpFlag        _{i + \relof} & = & \rOne       \\
			\mxpComputationExoInst        _{i + \relof} & = & \inst{LT}   \\
			\mxpComputationArgOneHi       _{i + \relof} & = & \col{a\_hi} \\
			\mxpComputationArgOneLo       _{i + \relof} & = & \col{a\_lo} \\
			\mxpComputationArgTwoHi       _{i + \relof} & = & \col{b\_hi} \\
			\mxpComputationArgTwoLo       _{i + \relof} & = & \col{b\_lo} \\
		\end{array} \right. \vspace{2mm} \\
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\wcpCallToLeq {
			anchorRow = i           ,
			relOffset = \relof      ,
			argOneHi  = \col{a\_hi} ,
			argOneLo  = \col{a\_lo} ,
			argTwoHi  = \col{b\_hi} ,
			argTwoLo  = \col{b\_lo} ,
		} & \define &
		\left\{ \begin{array}{lcl}
			\mxpComputationWcpFlag        _{i + \relof} & = & \rOne       \\
			\mxpComputationExoInst        _{i + \relof} & = & \inst{LEQ}  \\
			\mxpComputationArgOneHi       _{i + \relof} & = & \col{a\_hi} \\
			\mxpComputationArgOneLo       _{i + \relof} & = & \col{a\_lo} \\
			\mxpComputationArgTwoHi       _{i + \relof} & = & \col{b\_hi} \\
			\mxpComputationArgTwoLo       _{i + \relof} & = & \col{b\_lo} \\
		\end{array} \right. \vspace{2mm} \\
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\wcpCallToIszero  {
			anchorRow = i           ,
			relOffset = \relof      ,
			argOneHi  = \col{a\_hi} ,
			argOneLo  = \col{a\_lo} ,
		} & \define &
		\left\{ \begin{array}{lcl}
			\mxpComputationWcpFlag        _{i + \relof} & = & \rOne          \\
			\mxpComputationExoInst        _{i + \relof} & = & \inst{ISZERO}  \\
			\mxpComputationArgOneHi       _{i + \relof} & = & \col{a\_hi}    \\
			\mxpComputationArgOneLo       _{i + \relof} & = & \col{a\_lo}    \\
			\mxpComputationArgTwoHi       _{i + \relof} & = & 0              \\
			\mxpComputationArgTwoLo       _{i + \relof} & = & 0              \\
		\end{array} \right. \vspace{2mm} \\
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\eucCall {
			anchorRow = i       ,
			relOffset = \relof  ,
			argOne    = \col{a} ,
			argTwo    = \col{b} ,
		} & \define &
		\left\{ \begin{array}{lcl}
			\mxpComputationEucFlag        _{i + \relof} & = & \rOne   \\
			\mxpComputationArgOneLo       _{i + \relof} & = & \col{a} \\
			\mxpComputationArgTwoLo       _{i + \relof} & = & \col{b} \\
		\end{array} \right. \\
		% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% \multicolumn{3}{l}{
		% 	\resultMustBeTrue {
		% 		anchorRow = i      ,
		% 		relOffset = \relof ,
		% 	} \define \mxpMacroRes _{i + \relof} = \redm{1}
		% } \\
	\end{array} \right.
\]
\saNote{}
When using these constraints, one must make sure that the row index $i+\relof$ is that of a computation row. 
