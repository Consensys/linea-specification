The first set of columns arrives to the present module from the \mmioMod{} module:
\begin{enumerate}
    \item
        \blsStamp{}:
        module stamp; has simple $0/1$ increments;
    \item
        \blsId{}:
        unique identifier of a precompile \inst{CALL} triggering the present module;
        contains a context number derived from the \hubStamp{};
    \item
        \blsIndex{}:
        data limb index;
    \item
        \blsLimb{}:
        data limb; either input or output;
    \item
        \ct:
        counter column;
        counts continuously from $0$ to \maxCt{} then resets to $0$;
    \item
        \maxCt:
        counter-constant column;
        the maximum value $\ct$ should count to;
    \item
        \blsTotalSize{}:
        total size of input or output; Especially relevant for \inst{G1MSM}, \inst{G2MSM} and \inst{PAIRING\_CHECK} which have variable size inputs;
    \item
        \blsPhase{}:
        phase identifying which precompile is being called and whether the data represents inputs or outputs;
    \item
        \indexMax{}:
        maximum value of \blsIndex{} for a given phase;
    \item
        \blsSuccessBit{} \hubMmuMmioBlsPrediction{} \markAsPartiallyJustifiedHere{}:
        success bit of the operation;
\end{enumerate}
The following columns partake in the ``instruction decoding'' of the above:
\begin{multicols}{2}
    \begin{enumerate}
        \item \isPointEvaluationData{}
        \item \isPointEvaluationResult{}
        \item \isBlsGOneAddData{}
        \item \isBlsGOneAddResult{}
        \item \isBlsGOneMsmData{}
        \item \isBlsGOneMsmResult{}
        \item \isBlsGTwoAddData{}
        \item \isBlsGTwoAddResult{}
        \item \isBlsGTwoMsmData{}
        \item \isBlsGTwoMsmResult{}
        \item \isBlsPairingCheckData{}
        \item \isBlsPairingCheckResult{}
        \item \isBlsMapFpToGOneData{}
        \item \isBlsMapFpToGOneResult{}
        \item \isBlsMapFpTwoToGTwoData{}
        \item \isBlsMapFpTwoToGTwoResult{}
    \end{enumerate}
\end{multicols}
We further define:
\begin{enumerate}[resume]
    \item
        \totalInputs:
        In the context of \inst{G1MSM}, \inst{G2MSM} and \inst{PAIRING\_CHECK}, equals to the number of inputs passed to the precompile;
    \item
        \accInputs:
        In the context of \inst{G1MSM}, \inst{G2MSM} and \inst{PAIRING\_CHECK}, counts the inputs starting from 1. It is equal to 0 otherwise.
    \item
        $\byteCol{$\Delta$}$:
        byte column; used to justify that \blsId{} increments;
\end{enumerate}
The following batch of columns is relevant in the context of \inst{G1MSM}, \inst{G2MSM} and \inst{PAIRING\_CHECK}, which have variable size inputs.
In the case of \inst{PAIRING\_CHECK}, we refer to data supposedly containing a $G_1$ point as \textbf{small points} and to data supposedly containing a $G_2$ point as \textbf{large points}.
\begin{enumerate}[resume]
    \item
        \both{\internalChecksPassed}:
             binary column, constant for a given \blsId, which lights up when all the internal checks passed.
    \item
        \both{\malformedDataInternalBit}:
        binary column;
        may light up on data rows when a data malformation was detected in module;
        the pattern depends on the nature of the data;
        any data row where the module detects
    \item
        \both{\malformedDataInternalAcc}:
        binary column;
        accumulates the values of \malformedDataInternalBit{} over the course of a \blsId{};
    \item
        \both{\malformedDataInternalTot}:
        binary column, constant for a given \blsId{},
        which lights up when the data is malformed and it can be justified internally;
    \item
        \both{\malformedDataExternalBit} \blsPrediction{}:
        binary columns, constant for a given point, which lights up when that point does not belong to the expected field; % counter-constant
    \item
        \both{\malformedDataExternalAcc}:
        binary columns which lights up when \malformedDataExternalBit{} equals $1$;
    \item
        \both{\malformedDataExternalTot}:
        binary column, constant for a given \blsId, which lights up when the data is malformed and it needs to be justified extenrally;
    \item
        \both{\wellformedDataTrivial}:
        binary column, constant for a given \blsId, which lights up when the data is well formed and it is in the trivial case based on the value of the last data row of the corresponding pairing;
    \item
        \both{\wellformedDataNontrivial}:
        binary column, constant for  given \blsId, which lights up when the data is well formed and it is not in the trivial case based on the value of the last data row of the corresponding pairing;
\end{enumerate}
The following columns help us distinguish between qualitatively different data segments.
They are used by the
\inst{G1ADD},
\inst{G1MSM},
\inst{G2ADD},
\inst{G2MSM},
\inst{PAIRING\_CHECK}
precompiles.
\specTodo{} Add a table where we describe what passes for ``first input'' and ``second input'' for these cases.
\begin{enumerate}[resume]
    \item
        \isFirstInput:
        counter-constant binary column;
        lights up when the input is the first;
    \item
        \isSecondInput:
        counter-constant binary column;
        lights up when the input is the second;
\end{enumerate}
\begin{enumerate}[resume]
    \item
        \isInfinity:
        counter-constant binary column;
        may only light along rows containing (supposedly) curve points;
        lights up precisely if all coordinates vanish;
    \item
        \both{\nontrivialPairOfPointsBit}:
        pair-of-points-constant binary column;
        may only light up for data rows of the \inst{PAIRING\_CHECK} precompile (i.e. when $\isBlsPairingCheckData \equiv 1$);
        lights up precisely when neither point of the pair of points is the point at infinity;
    \item
        \both{\nontrivialPairOfPointsAcc}:
        pair-of-points-constant binary column;
        accumulates \nontrivialPairOfPointsBit{};
        used to set \wellformedDataNontrivial{};
\end{enumerate}
The following columns defines the external circuits interface:
\begin{enumerate}[resume]
    \item
        \both{\csPointEvaluation}:
        indicates if inputs should be sent to the circuit for \inst{POINT\_EVALUATION};
    \item
        \both{\csCOne}:
        indicates if inputs should be sent to the circuit for $C_1$ membership test;
    \item
        \both{\csGOne}:
        indicates if inputs should be sent to the circuit for $G_1$ membership test;
    \item
        \both{\csCTwo}:
        indicates if inputs should be sent to the circuit for $C_2$ membership test;
    \item
        \both{\csGTwo}:
        indicates if inputs should be sent to the circuit for $G_2$ membership test;
    \item
        \both{\csPairing}:
        indicates if inputs should be sent to the circuit for \inst{PAIRING\_CHECK};
    \item
        \both{\csGOneAdd}:
        indicates if inputs should be sent to the circuit for \inst{G1ADD};
    \item
        \both{\csGTwoAdd}:
        indicates if inputs should be sent to the circuit for \inst{G2ADD};
    \item
        \both{\csGOneMsm}:
        indicates if inputs should be sent to the circuit for \inst{G1MSM};
    \item
        \both{\csGTwoMsm}:
        indicates if inputs should be sent to the circuit for \inst{G2MSM};
    \item
        \both{\csMapFpToGOne}:
        indicates if inputs should be sent to the circuit for \inst{MAP\_FP\_TO\_G1};
    \item
        \both{\csMapFpTwoToGTwo}:
        indicates if inputs should be sent to the circuit for \inst{MAP\_FP2\_TO\_G2};
\end{enumerate}
The following columns are used for the $\wcpMod$ lookup
\begin{multicols}{2}
    \begin{enumerate}[resume]
        \item \wcpFlag
        \item \wcpArgOneHi
        \item \wcpArgOneLo
        \item \wcpArgTwoHi
        \item \wcpArgTwoLo
        \item \wcpRes
        \item \wcpInst
        \item[\vspace{\fill}]
    \end{enumerate}
\end{multicols}
