We impose the following constraints:
\begin{enumerate}
    \item \malformedDataInternalJustification{} is binary \quad (\trash)
    \item \malformedDataInternalJustification{} is stamp-constant \quad (\trash)
    \item \If $\locTransitionToResult _{i} = 1$ \Then
        \[
            \left\{ \begin{array}{lcl}
                \locInternalChecksPassed                 & \define & \partialChecks _{i}             \\
                \locInternalChecksFailed                 & \define & 1 - \locInternalChecksPassed    \\
                \malformedDataInternalJustification _{i} &    =    & \locInternalChecksFailed        \\
            \end{array} \right.
        \]
\end{enumerate}
\saNote{} Each precompile uses the last data row of the \partialChecks{} column to write whether the internal checks passed. This value is indicated through the shorthand \locInternalChecksPassed{}. Then, due to \textbf{stamp-constantcy}, \malformedDataInternalJustification{} column is constant and equal to  $\locInternalChecksFailed = 1 - \locInternalChecksPassed$ for a given \blsStamp{}.

\begin{enumerate}[resume]
    \item \If $\blsSuccessBit _{i} = 1$ \Then $\malformedDataInternalJustification _{i} = 0$ $(\trash)$
\end{enumerate}
\saNote{}
We label the final constraint (imposing that for an operation to be successful it must have passed the internal checks hurdle) with a $(\trash)$ only because it will be imposed explicitly in the sequel for every precompile within the present module.
