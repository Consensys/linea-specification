The value of $\blsTotalSize$ depends on several factors.
The first distinction is the precompile itself.
The second distinction is between data and result phases.
Along result rows $\blsTotalSize$ is entirely determined by the precompile (and we adopt the convention that $\blsTotalSize \equiv 0$ in case of a failure).
Along data rows $\blsTotalSize$ is entirely known for precompiles with fixed input size.
For variable input size precompiles, \inst{\prcNameBlsGOneMsm}, \inst{\prcNameBlsGTwoMsm} and \inst{\prcNameBlsPairingCheck}, we cannot \emph{a priori} constrain either \blsTotalSize{} or \indexMax{}.
We can only connect $\blsTotalSize$ to $\indexMax$ through the constraint~(\ref{bls: generalities: setting index max: connect total size and index max for variable size data}).

We define the following constraints:
\begin{enumerate}
  \item \If $\locIsData = 1$ \et $\locIsVariableSizeData = 0$ \Then
    \[
        \blsTotalSize _{i} = (\indexMax _{i} + 1) \cdot 16
    \]
  \item \If $\locIsResult = 1$ \Then
    \[
        \blsTotalSize _{i} = (\indexMax _{i} + 1) \cdot 16 \cdot \blsSuccessBit _{i}
    \]
\end{enumerate}