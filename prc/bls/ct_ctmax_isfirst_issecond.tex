The present section provides constraints for
\isFirstInput{}, \isSecondInput{},
\maxCt{} and \ct{}.
The constraints for these columns are tightly intertwined.
We start by defining the following module constants
\[
    \left\{ \begin{array}{lcl}
        \locCtMaxFirstInput_{i} & \!\!\! \define \!\!\! & \redm{...} \cdot \isBlsGOneMsmData_{i} + \redm{...} \cdot \isBlsGTwoMsmData_{i} + \redm{...} \cdot \isBlsPairingCheckData_{i} \\
        \locCtMaxSecondInput_{i} & \!\!\! \define \!\!\! & \redm{...} \cdot \isBlsGOneMsmData_{i} + \redm{...} \cdot \isBlsGTwoMsmData_{i} + \redm{...} \cdot \isBlsPairingCheckData_{i} \\
    \end{array} \right.
\]

Then, impose the following constraints
\begin{enumerate}
    \item $\isFirstInput$ and $\isSecondInput$ are binary \quad (\trash)
    \item $\isBlsGOneMsmData_{i} + \isBlsGTwoMsmData_{i} + \isBlsPairingCheckData_{i} = \isFirstInput_{i} + \isSecondInput_{i}$
\end{enumerate}

\saNote{}
\isBlsGOneMsmData{}, \isBlsGTwoMsmData{} and \isBlsPairingCheckData{} being exclusive binary implicitly enforces that
$\isFirstInput$ and $\isSecondInput$ are \textbf{exclusive binary flags}.


\begin{enumerate}[resume]
    \item we unconditionally impose that
        \[
            \begin{array}{l}
                \maxCt _{i} =
                \left[ \begin{array}{clcl}
                    + & \locCtMaxFirstInput_{i} & \cdot & \isFirstInput_{i} \\
                    + & \locCtMaxSecondInput_{i}& \cdot & \isSecondInput_{i} \\
                \end{array} \right] \\
            \end{array}
        \]
    \item $\maxCt$ is counter-constant \quad (\trash)
    \item $\isFirstInput$ and $\isSecondInput$ are counter-constant \quad (\trash)
\end{enumerate}
\saNote{} Counter-constancy of \maxCt{} and exclusive binaryness of $\isFirstInput$ and $\isSecondInput$ implicitly imposes counter-constancy of $\isFirstInput$ and $\isSecondInput$,
whence the (\trash) symbol.


% We now move on to the \textbf{transitions} of $\isSmallPoint$ and $\isLargePoint$.
% The first constraint below imposes that small points appear before large points,
% while the second constraint imposes that small and large points ``alternate.''
% \begin{enumerate}[resume]
%     \item \If $\isEcpairingData_{i} = 0$ \Then $\isSmallPoint_{i + 1} = \isEcpairingData_{i + 1}$
%     \item \If $\isEcpairingData_{i} = 1$ \et $\isEcpairingData_{i+1} = 1$ \Then
%         \begin{enumerate}
%             \item \If $\ct_{i} \neq \maxCt_{i}$ \Then
%                 \[
%                     \locTransitionFromSmallToLarge_{i} + \locTransitionFromLargeToSmall_{i} = 0 \quad (\trash)
%                 \]
%             \item \If $\ct_{i} =    \maxCt_{i}$ \Then
%                 \[
%                     \locTransitionFromSmallToLarge_{i} + \locTransitionFromLargeToSmall_{i} = 1
%                 \]
%         \end{enumerate}
%         where we use the following shorthands
%         \[
%             \left\{ \begin{array}{lcl}
%                 \locTransitionFromSmallToLarge_{i} & \define & \isSmallPoint_{i} \cdot \isLargePoint_{i + 1} \\
%                 \locTransitionFromLargeToSmall_{i} & \define & \isLargePoint_{i} \cdot \isSmallPoint_{i + 1} \\
%             \end{array} \right.
%         \]
%         \saNote{} The ``$\ct_{i} \neq \maxCt_{i}$'' case is redundant by counter-constancy of $\isSmallPoint$ and $\isLargePoint$,
%         whence the (\trash) symbol.
% \end{enumerate}
% We now impose standard constraints on the \ct, \maxCt{} pair:
% \begin{enumerate}[resume]
%     \item \If $\isEcpairingData_{i} = 0$ \Then
%         \[
%             \left\{ \begin{array}{lcl}
%                 \ct_{i}     & = & 0 \\
%                 \ct_{i + 1} & = & 0 \\
%             \end{array} \right.
%         \]
%     \item \If $\ct_{i} \neq \maxCt_{i}$ \Then $\ct_{i + 1} = 1 + \ct_{i}$
%     \item \If $\ct_{i} =    \maxCt_{i}$ \Then $\ct_{i + 1} = 0$
% \end{enumerate}

% \saNote{} These columns are only pertinent for the processing of \inst{ECPAIRING}'s.
