The present section provides the facilities to trigger the \wcpMod{} module.
We define the following constraint:
\[
    \left\{ \begin{array}{l}
        \wcpCallToLt {
            anchorRow = i             ,
            relOffset = \relof        ,
            argOneHi  = \col{a}       ,
            argOneLo  = \col{b}       ,
            argTwoHi  = \col{c}       ,
            argTwoLo  = \col{d}       ,
        }
        \vspace{4mm} \\
        \qquad \qquad \iff
        \left\{ \begin{array}{lcl}
                    \wcpFlag       _{i+\relof} & = & 1         \\
                    \wcpInst       _{i+\relof} & = & \inst{LT} \\
                    \wcpArgOneHi   _{i+\relof} & = & \col{a}   \\
                    \wcpArgOneLo   _{i+\relof} & = & \col{b}   \\
                    \wcpArgTwoHi   _{i+\relof} & = & \col{c}   \\
                    \wcpArgTwoLo   _{i+\relof} & = & \col{d}   \\
                \end{array} \right.
    \end{array} \right.
\]
and
\[
    \left\{ \begin{array}{l}
        \wcpCallToEq {
            anchorRow = i             ,
            relOffset = \relof        ,
            argOneHi  = \col{a}       ,
            argOneLo  = \col{b}       ,
            argTwoHi  = \col{c}       ,
            argTwoLo  = \col{d}       ,
        }
        \vspace{4mm} \\
        \qquad \qquad \iff
        \left\{ \begin{array}{lcl}
                    \wcpFlag       _{i+\relof} & = & 1         \\
                    \wcpInst       _{i+\relof} & = & \inst{EQ} \\
                    \wcpArgOneHi   _{i+\relof} & = & \col{a}   \\
                    \wcpArgOneLo   _{i+\relof} & = & \col{b}   \\
                    \wcpArgTwoHi   _{i+\relof} & = & \col{c}   \\
                    \wcpArgTwoLo   _{i+\relof} & = & \col{d}   \\
                \end{array} \right.
    \end{array} \right.
\]
and
\[
    \left\{ \begin{array}{l}
        \wcpCallToIszero {
            anchorRow = i            ,
            relOffset = \relof       ,
            argOneHi  = \col{a}      ,
            argOneLo  = \col{b}      ,
        }
        \vspace{4mm} \\
        \qquad \qquad \iff
        \left\{ \begin{array}{lcl}
                    \wcpFlag       _{i+\relof} & = & 1                \\
                    \wcpInst       _{i+\relof} & = & \inst{ISZERO}    \\
                    \wcpArgOneHi   _{i+\relof} & = & \col{a}          \\
                    \wcpArgOneLo   _{i+\relof} & = & \col{b}          \\
                    \wcpArgTwoHi   _{i+\relof} & = & 0 \quad (\trash) \\
                    \wcpArgTwoLo   _{i+\relof} & = & 0 \quad (\trash) \\
                \end{array} \right.
    \end{array} \right.
\]
and
\[
    \left\{ \begin{array}{l}
        \wcpGeneralizedCallToLt {
            anchorRow = i             ,
            relOffset = \relof        ,
            argOneThree = \col{a}     ,
            argOneTwo   = \col{b}     ,
            argOneOne   = \col{c}     ,
            argOneZero  = \col{d}     ,
            argTwoThree = \col{e}     ,
            argTwoTwo   = \col{f}     ,
            argTwoOne   = \col{g}     ,
            argTwoZero  = \col{h}     ,
        }
        \vspace{4mm} \\
        \qquad \qquad \iff
        \left\{ \begin{array}{l}
            \wcpCallToLt {
                anchorRow = i             ,
                relOffset = \relof + 1    ,
                argOneHi  = \col{a}       ,
                argOneLo  = \col{b}       ,
                argTwoHi  = \col{e}       ,
                argTwoLo  = \col{f}       ,
            } \\
            \wcpCallToEq {
                anchorRow = i             ,
                relOffset = \relof + 2    ,
                argOneHi  = \col{a}       ,
                argOneLo  = \col{b}       ,
                argTwoHi  = \col{e}       ,
                argTwoLo  = \col{f}       ,
            } \\
            \wcpCallToLt {
                anchorRow = i             ,
                relOffset = \relof + 3    ,
                argOneHi  = \col{c}       ,
                argOneLo  = \col{d}       ,
                argTwoHi  = \col{g}       ,
                argTwoLo  = \col{h}       ,
            } \\
            \wcpRes_{i+\relof} = \wcpRes_{i+\relof+1} + (\wcpRes_{i+\relof+2}  \cdot  \wcpRes_{i+\relof+3}) \\
        \end{array} \right.
    \end{array} \right.
\]
and
% TODO: do we actually need this to check if a point is at infinity or can we just check that the sum of the coordinates is zero?
\[
    \left\{ \begin{array}{l}
        \wcpGeneralizedCallToIszero {
            anchorRow = i             ,
            relOffset = \relof        ,
            argOneThree = \col{a}     ,
            argOneTwo   = \col{b}     ,
            argOneOne   = \col{c}     ,
            argOneZero  = \col{d}     ,
        }
        \vspace{4mm} \\
        \qquad \qquad \iff
        \left\{ \begin{array}{l}
            \wcpCallToIszero {
                anchorRow = i             ,
                relOffset = \relof + 1    ,
                argOneHi  = \col{a}       ,
                argOneLo  = \col{b}       ,
            } \\
            \wcpCallToIszero {
                anchorRow = i             ,
                relOffset = \relof + 2    ,
                argOneHi  = \col{c}       ,
                argOneLo  = \col{d}       ,
            } \\
            \wcpRes_{i+\relof} = \wcpRes_{i+\relof+1} \cdot \wcpRes_{i+\relof+2}
        \end{array} \right.
    \end{array} \right.
\]



