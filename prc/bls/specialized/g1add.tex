% TODO: the G2 is similar but with 256 bytes points rather than 128 bytes
\[
    \boxed{\text{All constraints in this subsection assume }
        \left\{ \begin{array}{lcl}
            \isBlsGOneAddData & =    & 1            \\
            \blsId_{i}        & \neq & \blsId_{i-1} \\
        \end{array} \right.
    }
\]

We introduce the following (local) shorthands:
\[
    \left\{ \begin{array}{lclr}
        \locAXThree & \define & \blsLimb_{i}      \\
        \locAXTwo   & \define & \blsLimb_{i + 1}  \\
        \locAXOne   & \define & \blsLimb_{i + 2}  \\
        \locAXZero  & \define & \blsLimb_{i + 3}  \\
        \locAYThree & \define & \blsLimb_{i + 4}  \\
        \locAYTwo   & \define & \blsLimb_{i + 5}  \\
        \locAYOne   & \define & \blsLimb_{i + 6}  \\
        \locAYZero  & \define & \blsLimb_{i + 7}  \\
        \locBXThree & \define & \blsLimb_{i + 8}  \\
        \locBXTwo   & \define & \blsLimb_{i + 9}  \\
        \locBXOne   & \define & \blsLimb_{i + 10} \\
        \locBXZero  & \define & \blsLimb_{i + 11} \\
        \locBYThree & \define & \blsLimb_{i + 12} \\
        \locBYTwo   & \define & \blsLimb_{i + 13} \\
        \locBYOne   & \define & \blsLimb_{i + 14} \\
        \locBYZero  & \define & \blsLimb_{i + 15} \\
    \end{array} \right.
\]

We set the following constraints:

\begin{description}
    \item[\underline{Row $n^°(i)$:}]
        we impose
            \[
                \callToWellFormedCoordinatesBls {
                    anchorRow = i             ,
                    relOffset = 0             ,
                    argOneThree = \locAXThree ,
                    argOneTwo   = \locAXTwo   ,
                    argOneOne   = \locAXOne   ,
                    argOneZero  = \locAXZero  ,
                    argTwoThree = \locAYThree ,
                    argTwoTwo   = \locAYTwo   ,
                    argTwoOne   = \locAYOne   ,
                    argTwoZero  = \locAYZero  ,
                }           
            \]
        as well as define the shorthand
            \[
                \locAIsWellFormed \define \partialChecks_{i}
            \]

        \item[\underline{Row $n^°(i + 8)$:}]
        we impose
            \[
                \callToWellFormedCoordinatesBls {
                    anchorRow = i             ,
                    relOffset = 8             ,
                    argOneThree = \locBXThree ,
                    argOneTwo   = \locBXTwo   ,
                    argOneOne   = \locBXOne   ,
                    argOneZero  = \locBXZero  ,
                    argTwoThree = \locBYThree ,
                    argTwoTwo   = \locBYTwo   ,
                    argTwoOne   = \locBYOne   ,
                    argTwoZero  = \locBYZero  ,
                }           
            \]
        as well as define the shorthand
            \[
                \locBIsWellFormed \define \partialChecks_{i + 8}
            \]
            % TODO: IS_INFINITY is set within the calls, we need to read it to decide if we should call or not the external circuit      
    \item[\underline{Justifying the \blsSuccessBit{}:}]
          we define the following shorthand
          \[
              \locInternalChecksPassed \define \partialChecks_{i+\indexMaxBlsGOneAddData} \\
          \]

          and impose the following constraints
          
          \[
              \left\{ \begin{array}{lcl}
                  \locInternalChecksPassed     & = & \locAIsWellFormed \cdot \locBIsWellFormed                        \\
                  \If \locInternalChecksPassed & = & 0 ~ \Then \blsSuccessBit _{i} = 0                                \\
                  \If \locInternalChecksPassed & = & 1 ~ \Then \blsSuccessBit _{i} \equiv 1 - \notOnCXAccMax _{i}     \\
              \end{array} \right.
          \]
\end{description}

