\[
    \boxed{\text{All constraints in this subsection assume }
        \left\{ \begin{array}{lcl}
            \isBlsPairingCheckData & =    & 1            \\
            \blsId_{i}             & \neq & \blsId_{i-1} \\
        \end{array} \right.
    }
\]

We introduce the following (local) shorthands:
\[
    \left\{ \begin{array}{lclr}
        \locAXHi                         & \define & \blsLimb _{i}                             \\
        \locAXLo                         & \define & \blsLimb _{i + 1}                         \\
        \locAYHi                         & \define & \blsLimb _{i + 2}                         \\
        \locAYLo                         & \define & \blsLimb _{i + 3}                         \\
        \locBXImHi                       & \define & \blsLimb _{i + 4}                         \\
        \locBXImLo                       & \define & \blsLimb _{i + 5}                         \\
        \locBXReHi                       & \define & \blsLimb _{i + 6}                         \\
        \locBXReLo                       & \define & \blsLimb _{i + 7}                         \\
        \locBYImHi                       & \define & \blsLimb _{i + 8}                         \\
        \locBYImLo                       & \define & \blsLimb _{i + 9}                         \\
        \locBYReHi                       & \define & \blsLimb _{i + 10}                        \\
        \locBYReLo                       & \define & \blsLimb _{i + 11}                        \\
        \locInternalChecksPassed         & \define & \partialChecks     _{i + \indexMaxEcPairingDataMin} \\
        \locPreviousInternalChecksPassed & \define & \partialChecks     _{i - \redm{1}}                  \\
    \end{array} \right.
\]
We introduce the following constraints:
\begin{description}
    \item[\underline{Row $n^°(i)$:}]
            we impose
                \[
                    \callToWellFormedCoordinatesBls {
                        anchorRow = i             ,
                        relOffset = 0             ,
                        argOneThree = \locAXThree ,
                        argOneTwo   = \locAXTwo   ,
                        argOneOne   = \locAXOne   ,
                        argOneZero  = \locAXZero  ,
                        argTwoThree = \locAYThree ,
                        argTwoTwo   = \locAYTwo   ,
                        argTwoOne   = \locAYOne   ,
                        argTwoZero  = \locAYZero  ,
                    }           
                \]
            as well as define the shorthand
                \[
                    \locAIsWellFormed \define \partialChecks_{i}
                \]
\end{description}

\begin{description}
    \item[\underline{Row $n^°(i+8)$:}]
        we impose
            \[
                \callToWellFormedCoordinatesBlsTwo {
                    anchorRow = i               ,
                    relOffset = 8               ,
                    argOneSeven = \locBXImThree ,
                    argOneSix   = \locBXImTwo   ,
                    argOneFive  = \locBXImOne   ,
                    argOneFour  = \locBXImZero  ,
                    argOneThree = \locBXReThree ,
                    argOneTwo   = \locBXReTwo   ,
                    argOneOne   = \locBXReOne   ,
                    argOneZero  = \locBXReZero  ,
                    argTwoSeven = \locBYImThree ,
                    argTwoSix   = \locBYImTwo   ,
                    argTwoFive  = \locBYImOne   ,
                    argTwoFour  = \locBYImZero  ,
                    argTwoThree = \locBYReThree ,
                    argTwoTwo   = \locBYReTwo   ,
                    argTwoOne   = \locBYReOne   ,
                    argTwoZero  = \locBYReZero  ,
                }                
            \]
        as well as define the shorthand
            \[
                \locBIsWellFormed \define \partialChecks_{i + 8}
            \]

\end{description}
\begin{description}
    \item[\underline{Propagation of \locInternalChecksPassed:}]
          The following constraint defines the value of $\locInternalChecksPassed$ for the first pair and the subsequents, if any.
          For each subsequent, $\locPreviousInternalChecksPassed$ is propagated so as to compute the latest $\locInternalChecksPassed$.
          Note that this approach is adopted to deal with an arbitrary number of input pairings:
          \begin{enumerate}
              \item \If $\accInputs_{i} = 1$ \Then
                    \[
                        \locInternalChecksPassed = \locAIsWellFormed \cdot \locBIsWellFormed
                    \]
              \item \If $\accInputs_{i} \neq 1$ \Then
                    \begin{enumerate}
                        \item $\partialChecks_{i + 22} = \locAIsWellFormed \cdot \locBIsWellFormed$
                        \item $\locInternalChecksPassed = \partialChecks_{i + 22} \cdot \locPreviousInternalChecksPassed$
                    \end{enumerate}
          \end{enumerate}
\end{description}
\saNote{} \If $\isBlsPairingCheckData_{i} = 0$ \Then $\accInputs_{i} = 0$ and the first pair corresponds to $\accInputs_{i} = 1$.
\begin{description}
    \item[\underline{Justifying the \blsSuccessBit{}:}]
          We impose the following constraints
          \begin{enumerate}
              \item \If $\malformedDataInternalTot _{i}= 1$ \Then $\blsSuccessBit _{i} = 0$
              \item \If $\malformedDataInternalTot _{i}= 0$ \Then $\blsSuccessBit_{i} = 1 - \notOnGXAccMax _{i}$
          \end{enumerate}
\end{description}
