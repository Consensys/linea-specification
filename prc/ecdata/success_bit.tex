We remind the reader that
for \instEcrecover{}
the interpretation of \ecdataSuccessBit{} is
\[
	\ecdataSuccessBit \equiv 1 \iff \text{well formed inputs and public address recovered}
\]
this is the difference the precompile returning $()$ and returning $\textbf{o} \in \mathbb{B}_{\,\evmWordSize}$ represening 12 zero bytes followed the 20 bytes of the recovered address;

\par
for \instEcadd{} and \instEcmul{}
the interpretation of \ecdataSuccessBit{} is
\[
	\ecdataSuccessBit \equiv 1 \iff \text{well formed inputs}
\]
this is the difference between
the precopile failing (consuming all the call gas and putting $0$ on the caller's stack) and returning $()$ i.e. nothing
the precompile succeeding (putring $1$ on the caller stack) and returning some $\textbf{o} \in \mathbb{B}_{\,\redm{64}}$;

\par
for \instEcpairing{}
the interpretation of \ecdataSuccessBit{} is
\[
	\ecdataSuccessBit \equiv 1 \iff \text{well formed inputs}
\]
this is the difference between
the precopile failing (consuming all the call gas and putting $0$ on the caller's stack) and returning $()$ i.e. nothing
the precompile succeeding (putring $1$ on the caller stack) and returning some $\textbf{o} \in \mathbb{B}_{\,\evmWordSize}$.
