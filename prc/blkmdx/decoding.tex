We define the following shorthand
\[
	\left\{ \begin{array}{lcl}
		\flagSum_{i} & \define &
		\left[ \begin{array}{cr}
			+ & \isModexpBase      _{i} \\
			+ & \isModexpExponent  _{i} \\
			+ & \isModexpModulus   _{i} \\
			+ & \isModexpResult    _{i} \\
			+ & \isBlakeData       _{i} \\
			+ & \isBlakeParams     _{i} \\
			+ & \isBlakeResult     _{i} \\
		\end{array} \right] \vspace{2mm} \\
		\weightedPhaseFlagSum_{i} & \define &
		\left[ \begin{array}{crcl}
			+ & \phaseModexpBase     & \!\!\!\cdot\!\!\! & \isModexpBase      _{i} \\
			+ & \phaseModexpExponent & \!\!\!\cdot\!\!\! & \isModexpExponent  _{i} \\
			+ & \phaseModexpModulus  & \!\!\!\cdot\!\!\! & \isModexpModulus   _{i} \\
			+ & \phaseModexpResult   & \!\!\!\cdot\!\!\! & \isModexpResult    _{i} \\
			+ & \phaseBlakeData      & \!\!\!\cdot\!\!\! & \isBlakeData       _{i} \\
			+ & \phaseBlakeParams    & \!\!\!\cdot\!\!\! & \isBlakeParams     _{i} \\
			+ & \phaseBlakeResult    & \!\!\!\cdot\!\!\! & \isBlakeResult     _{i} \\
		\end{array} \right] \vspace{2mm} \\
		\indexMaxFlagSum _{i} & \define &
		\left[ \begin{array}{crcl}
			+ & ( \numberOfLimbsForModexpArgumentsAndResult - 1 ) & \!\!\!\cdot\!\!\! & \isModexpBase     _{i} \\
			+ & ( \numberOfLimbsForModexpArgumentsAndResult - 1 ) & \!\!\!\cdot\!\!\! & \isModexpExponent _{i} \\
			+ & ( \numberOfLimbsForModexpArgumentsAndResult - 1 ) & \!\!\!\cdot\!\!\! & \isModexpModulus  _{i} \\
			+ & ( \numberOfLimbsForModexpArgumentsAndResult - 1 ) & \!\!\!\cdot\!\!\! & \isModexpResult   _{i} \\
			+ & ( \numberOfLimbsForBlakeData                - 1 ) & \!\!\!\cdot\!\!\! & \isBlakeData      _{i} \\
			+ & ( \numberOfLimbsForBlakeParams              - 1 ) & \!\!\!\cdot\!\!\! & \isBlakeParams    _{i} \\
			+ & ( \numberOfLimbsForBlakeResults             - 1 ) & \!\!\!\cdot\!\!\! & \isBlakeResult    _{i} \\
		\end{array} \right] \vspace{2mm} \\
	\end{array} \right.
\]
and impose the following:
\begin{enumerate}
	\item $\flagSum$ is binary;
	\item \If $\blkMdxStamp_{i} =    0$ \Then $\flagSum_{i} = 0$
	\item \If $\blkMdxStamp_{i} \neq 0$ \Then $\flagSum_{i} = 1$
	\item furthermore
		\[
			\left\{ \begin{array}{lcl}
				\modexpBlakePhase _{i} & \!\!\!=\!\!\! & \weightedPhaseFlagSum _{i} \\
				\indexMax         _{i} & \!\!\!=\!\!\! & \indexMaxFlagSum      _{i} \\
			\end{array} \right.
		\]
\end{enumerate}
The above thus enforces that
\isModexpBase    {},
\isModexpExponent{},
\isModexpModulus {},
\isModexpResult  {},
\isBlakeData     {},
\isBlakeParams   {} and
\isBlakeResult   {}
are indeed \textbf{exclusive binary columns}.
It also enforces that every non-padding-row is part of precisely one of these perspectives. 

\saNote{} The only requirement we place on the weights
$\phaseModexpBase$,
$\phaseModexpExponent$, \dots,
is that they be \textbf{pairwise distinct and nonzero}.
See note~(\ref{blake + modexp: constancies: implied index constancy of the binary flags}).

\saNote{}
As of \cite{EIP-7823}, arguments of \macroModexp{} calls must be of (byte) size at most
\[
	\modexpMaxByteSizeName \define \modexpMaxByteSizeValue
\]
With a \limb{} column of $\llarge{}$-byte limb capacity, this amounts to (at most) \numberOfLimbsForModexpArgumentsAndResult{}
rows per input and per result.
