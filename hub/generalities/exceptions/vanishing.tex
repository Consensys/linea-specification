\begin{center}
	\boxed{\text{All constraints in this section are written under the assumption } \peekStack_{i} = 1.}
\end{center}
What follows are constraints preventing certain instruction families from triggering certain exceptions.
Thus reducing the complexity of the ``exception analysis'' required in the instruction handling.
\begin{enumerate}
	\item $\stackOpcx _{i} = \stackDecInvalidFlag _{i}$
	\item \If $\stackDecMxpFlag    _{i} = 0$ \Then $\stackMxpx    _{i} = 0$
	\item \If $\stackDecJumpFlag   _{i} = 0$ \Then $\stackJumpx   _{i} = 0$
	\item \If $\stackDecStaticFlag _{i} = 0$ \Then $\stackStaticx _{i} = 0$
	\item \If $\stackInst _{i} \neq \inst{RETURNDATACOPY}$ \Then $ \stackRdcx    _{i} = 0 $
	\item \If $\stackInst _{i} \neq \inst{SSTORE}$         \Then $ \stackSstorex _{i} = 0 $
	\item \If $\stackInst _{i} \neq \inst{RETURN}$         \Then $ \stackIcpx    _{i} + \stackMaxcsx _{i} = 0 $
\end{enumerate}
\saNote{}
More details will be given about $\stackIcpx$ and $\stackMaxcsx$ in section~(\ref{hub: instruction handling: halt: revert}). 
Indeed, these exceptions can only apply in deployment contexts and the first one requires a nonzero \col{size} argument for the \inst{RETURN} instruction. 
