The present section sets some of the constraints for the ``refund columns''.
To simplify processing we introduce \textbf{two} refund counters, \refund{} and $\refund\new$.
The underlying idea is simple: $\refund\new$ contains the refund counter post opcode execution.
Furthermore refunds are accrued \emph{if and only if} they will not be reverted later on.

Recall that gas refunds may only be granted for the
\inst{SSTORE} opcode
We shall therefore impose that, for all other opcodes, $\refund \new \equiv \refund$.
The precise conditions which lead to gas refunds being granted will be described when we deal with the processing of \inst{SSTORE} in section
\ref{hub: instruction handling: sto}.

\saNote{} Prior to \cite{EIP-3529} the \inst{SELFDESTRUCT} opcode could also contribute to refunds.

When an execution context reverts, all refunds accrued during the execution of said execution context are discarded.
Implementations of the \evm{} typically achieve this by reverting to a snapshot (including accrued state variables) taken before transaction processing proper or before executing a \inst{CALL}-type or \inst{CREATE}-type opcode.
This resets refunds related to \inst{SSTORE} instructions (as well as purges addresses from the \inst{SELFDESTRUCT} set added by the reverting execution context and resets other (accrued) state variables.
Rather than roll back said refunds, purge addresses from a \inst{SELFDESTRUCT} set, etc\dots{} our \zkEvm{} design \textbf{simply does not tally refunds generated by execution contexts that will revert.}
Recall that execution contexts which will end up reverting are characterized by (the context-constant bit) $\cnWillRev \equiv 1$.
Our \zkEvm{} design thus has has present knowledge of future rollbacks and can decide on that basis which refunds to grant and which to ignore.
