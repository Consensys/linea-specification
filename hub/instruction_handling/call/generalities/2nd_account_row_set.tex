\begin{center}
	\boxed{%
		\text{The constraints presented below require that }
		\left\{ \begin{array}{lcl}
			\peekScenario                      _{i + \callFirstScenarioRowOffset} & = & 1 \\
			\scenCallRequiresBothAccountsTwice _{i + \callFirstScenarioRowOffset} & = & 1 \\
		\end{array} \right.
		}
\end{center}
Consider a \inst{CALL}-type instruction which falls into one of the following categories:
\begin{itemize}
	\item a pure transfer to an externally owned account is eventually reverted,
	\item a \inst{CALL} to a smart contract is unsuccessful or
	\item a \inst{CALL} to a smart contract is successful but later on the caller frame is reverted,
	\item a (successful) \inst{CALL} to precompile is (eventually) reverted,
\end{itemize}
where we abuse nomenclature as explained in
section~(\ref{hub: instruction handling: call: general approach}),
in each and every one of these scenarios
certain account operations must be undone.
These undoing operations pertain to
(\emph{a}) the value transfer, both for the caller and callee,
(\emph{b}) the warmth update of the callee.
\begin{description}
		\input{instruction_handling/call/generalities/rows/2nd_set/A___caller}
		\input{instruction_handling/call/generalities/rows/2nd_set/A___caller_balance}
		\input{instruction_handling/call/generalities/rows/2nd_set/B___callee}
		\input{instruction_handling/call/generalities/rows/2nd_set/B___callee_warmth_and_dom_sub_stamps}
		\input{instruction_handling/call/generalities/rows/2nd_set/C___delegate}
		\input{instruction_handling/call/generalities/rows/2nd_set/C___delegate_warmth_and_dom_sub_stamps}
\end{description}

\noindent Table~(\ref{hub: instruction handling: call: generalities: fig: when to revert warmth and balance}) below subsumes when these operations must be undone:
\begin{figure}
	\begin{center}
		% \hspace*{-2cm}
		\renewcommand{\arraystretch}{1.5}
		\begin{tabular}{|l|l|}
			\hline
			\inst{CALL}-scenario          & Callee account actions                                 \\ \hline \hline
			\scenCallEoaSuccessWillRevert & \undoSignifier{} balance update with \textcolor{draculapurple}{caller revert}     \\
			& \undoSignifier{} warmth  update with \textcolor{draculapurple}{caller revert}     \\ \hline \hline
			\scenCallSmcFailureWillRevert & \undoSignifier{} balance update with \textcolor{draculaorange}{child failure}     \\
			& \undoSignifier{} warmth  update with \textcolor{draculapurple}{caller revert}     \\ \hline
			\scenCallSmcFailureWontRevert & \undoSignifier{} balance update with \textcolor{draculaorange}{child failure}     \\
			& \sameSignifier{} warmth as after initial update        \\ \hline
			\scenCallSmcSuccessWillRevert & \undoSignifier{} balance update with \textcolor{draculapurple}{caller revert}     \\
			& \undoSignifier{} warmth  update with \textcolor{draculapurple}{caller revert}     \\ \hline \hline
			\scenCallPrcSuccessWillRevert & \undoSignifier{} balance update with \textcolor{draculapurple}{caller revert}     \\ \hline
		\end{tabular}
		\caption{Observe that there is \textbf{no undoing of the warmth update} in the \scenCallPrcSuccessWillRevert{} case. Precompiles are (constrained to be) perpetually warm in our arithmetization, see section~(\ref{hub: consistencies: account}).}
		\label{hub: instruction handling: call: generalities: fig: when to revert warmth and balance}
	\end{center}
\end{figure}

