\item[\underline{Setting the \callerName{} balance operation on account-row $n^Â°(i + \callFirstCallerAccountRowOffset)$:}]
	we impose that
	\begin{enumerate}
		\item \If $\scenCallBalanceUpdateNotRequired _{i} = 1$ \Then
			\[
				\accSameBalance
				{i}{\callFirstCallerAccountRowOffset}
			\]
		\item \If $\scenCallBalanceUpdateRequired _{i} = 1$ \Then
			\begin{enumerate}
				\item \If $\locIsCall = 1$ \Then
					\[
						\accDecrementBalance
						{i}{\callFirstCallerAccountRowOffset}{\locValueLo}
					\]
				\item \If $\locIsCallcode + \locIsDelegatecall + \locIsStaticcall = 1$ \Then
					\[
						\accSameBalance
						{i}{\callFirstCallerAccountRowOffset}
					\]
			\end{enumerate}
			\saNote{} \label{hub: instruction handling: call: generalities: first account rows: value transfer subtleties}
			The above may alternatively be implemented without case disjunction as
			\[
				\accDecrementBalance
				{i}{\callFirstCallerAccountRowOffset}{\locIsCall \cdot \locValueLo}
			\]
			Either way the above reflects that fact that only \inst{CALL} may \emph{actually} transfer value.
			The \inst{CALL}-type instruction \inst{CALLCODE} also has a ``\locValue'' argument but it doesn't set off a value transfer.
			This ``\locValue'' becomes the ``call value'' of the child context.
			It is noteworthy that while no \emph{actual} value transfer takes place,
			\inst{CALLCODE} may nonetheless incur a value transfer cost.
	\end{enumerate}

