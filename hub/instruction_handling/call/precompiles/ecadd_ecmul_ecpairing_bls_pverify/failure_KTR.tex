\begin{center}
	\boxed{%
		\text{The constraints presented below assume that }
		\left\{ \begin{array}{lcl}
			\peekScenario     _{i}      & = & 1 \\
			\left[ \begin{array}{cr}
				+ & \scenEcadd               _{i} \\
				+ & \scenEcmul               _{i} \\
				+ & \scenEcpairing           _{i} \\
				+ & \scenPrecompileCommonBls _{i} \\
				+ & \scenPVerify             _{i} \\
			\end{array} \right]
			& = & 1 \\
			\scenPrcFailureKnownToRam _{i} & = & 1 \\
		\end{array} \right.
		}
\end{center}
We are thus assuming that the present row is the first of the second phase of dealing with one of the following precompiles: \instEcadd{}, \instEcmul{}, \instEcpairing{}, \instPVerify{}.
We are furthermore assuming that $\scenPrcFailureKnownToRam \equiv 1$.
The only constraint we are missing at this point is imposing that \textbf{call data be nonempty} and updating the caller's call data\footnote{though this already happens implicitly}:
\begin{description}
	\item[\underline{Call data must be nonempty:}] 
		we impose \( \locExtractCallData = 1. \)
	\item[\underline{\underline{Context-row $n^Â°(i + \prcCommonFKTRContextRowOffset)$:}}] 
		we impose $\nonContextProvidesEmptyReturnData {i}{\prcCommonFKTRContextRowOffset}$ \quad $(\trash)$
\end{description}
