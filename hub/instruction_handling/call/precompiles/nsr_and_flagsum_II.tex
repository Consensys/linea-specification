We settle for every precompile the relevant ``\col{flag sums}'' and ``\col{nsr's}''.
A lot of them are the same. We thus introduce some high level shorthands first
\[
	\left\{ \begin{array}{lclcr}
		\locStandardFailureFlagSum & \define &
		\left[ \begin{array}{cl}
			+ & \peekScenario  _{i    } \\
			+ & \peekMisc      _{i + 1} \\
			+ & \peekContext   _{i + 2} \\
		\end{array} \right] & \text{and} & \locStandardFailureNsr = 3
		\vspace{2mm} \\
		\locStandardSuccessFlagSum & \define &
		\left[ \begin{array}{cl}
			+ & \peekScenario  _{i    } \\
			+ & \peekMisc      _{i + 1} \\
			+ & \peekMisc      _{i + 2} \\
			+ & \peekMisc      _{i + 3} \\
			+ & \peekContext   _{i + 4} \\
		\end{array} \right] & \text{and} & \locStandardSuccessNsr = 5 \\
	\end{array} \right.
\]
We now tackle the case of interest:
\begin{description}
	\item[\underline{\underline{Shorthands for \instEcrecover{}, \instShaTwo{} and \instRipemd{}:}}]
		for
		\[
			\loc{xxx} \in \left\{ \loc{ecrecover}, ~ \loc{sha2}, ~ \loc{ripemd} \right\}
		\]
		we set
		\[
			\left\{ \begin{array}{lcl}
				\locFlagSumXxxFKTH    & \define & \locStandardFailureFlagSum \\
				\locFlagSumXxxFKTR    & \equiv  & \leftUndefined             \\
				\locFlagSumXxxSuccess & \define & \locStandardSuccessFlagSum \\
				\locNsrXxxFKTH        & \define & \locStandardFailureNsr     \\
				\locNsrXxxFKTR        & \equiv  & \leftUndefined             \\
				\locNsrXxxSuccess     & \define & \locStandardSuccessNsr     \\
			\end{array} \right.
		\]
\end{description}
\saNote{}\label{hub: instruction handling: call: precompiles: flag sums and nsr II: the 2 distinct success scenarios for ECRECOVER}
There are actually two fundamentally distinct ``success'' scenarios for \instEcrecover{}.
Recall that ``success'' (i.e. $\scenPrcSuccess \equiv 1$) for \instEcrecover{} simply means that the precompile is provided with sufficient gas.
A successfull call to the \instEcrecover{} precompile may yet lead to two very distinct scenarios:
\begin{itemize}
	\item $\locMmuRecoverSuccess \equiv 0$ i.e. \textbf{address recovery fails}    and $\textbf{o} = ()$;
	\item $\locMmuRecoverSuccess \equiv 1$ i.e. \textbf{address recovery succeeds} and $\textbf{o} \in \mathbb{B}_{32}$;
\end{itemize}
In the first case we \emph{could} get away with fewer rows.
Indeed, the output of the precompile  is known to be empty and we \emph{could} skip the two miscellaneous-rows that are responsible for
(\emph{a}) fully moving the return data from a \ecDataMod{} module to a fictitious execution context's \textsc{ram}
(\emph{b}) doing a (partial) copy of the (freshly transferred) return data to the part of memory in the current execution context made available by the underlying \inst{CALL}-type instruction for that purpose.
We have chosen \textbf{not} to go for this optimization as it would complexify the computation of \nonStackRows{}.
The above definitions for flag sums and \col{nsr}'s are therefore somewhat wasteful.
\begin{description}
	\item[\underline{\underline{Shorthands for \instIdentity{}:}}] the \instIdentity{} precompile requires special care:
		\[
			\left\{ \begin{array}{lcl}
				\locFlagSumIdentityFKTH    & \define & \locStandardFailureFlagSum \\
				\locFlagSumIdentityFKTR    & \equiv  & \leftUndefined             \\
				\locFlagSumIdentitySuccess & \define &
				\left[ \begin{array}{cl}
					+ & \peekScenario  _{i    } \\
					+ & \peekMisc      _{i + 1} \\
					+ & \peekMisc      _{i + 2} \\
					+ & \peekContext   _{i + 3} \\
				\end{array} \right] \vspace{2mm} \\
				\locNsrIdentityFKTH    & \define & \locStandardFailureNsr \\
				\locNsrIdentityFKTR    & \equiv  & \leftUndefined         \\
				\locNsrIdentitySuccess & \define & 4                      \\
			\end{array} \right.
		\]
\end{description}
\saNote{}
Several precompiles (elliptic curve precompiles \instEcrecover{}, \instEcadd{}, \instEcmul{}, \instEcpairing{}, \instPVerify{}
and some hashing precompiles \instShaTwo{} and \instRipemd{})
are dealt with as follows:
\begin{enumerate}
	\item copying call data to the relevant exogenous data module;
	\item copying (if appropriate) the full return data from said exo data module to a dedicated execution context's \textsc{ram};
	\item (potentially) transferring parts of that return data to the current execution context's \textsc{ram};
\end{enumerate}
The above chain of events requires up to \textbf{three} accesses to \textsc{ram} and as such \textbf{three} individual miscellaneous rows.
The \instIdentity{} precompile, on the other hand, happens in \textbf{two stages}:
\begin{enumerate}
	\item copying call data to a dedicated execution context's \textsc{ram} where it will serve as source of return data;
	\item (potentially) transferring parts of that call data to the current execution context's \textsc{ram};
\end{enumerate}
In order to achieve the above \textbf{two} miscellaneous-rows are sufficient.
The above explains the special value attributed to \locFlagSumIdentitySuccess{} compared to other similar flag sums.
\begin{description}
	\item[\underline{\underline{Shorthands for \instModexp{}:}}] the \instModexp{} precompile requires special care:
		\[
			\left\{ \begin{array}{lcl}
				\locFlagSumModexpFKTH & \equiv  & \leftUndefined \\
				\locFlagSumModexpFKTR & \define &
				\left[ \begin{array}{cr}
					+ & \peekScenario _{i     } \\
					+ & \peekMisc     _{i +  1} \\
					+ & \peekMisc     _{i +  2}
					+   \peekMisc     _{i +  3}
					+   \peekMisc     _{i +  4} \\
					+ & \peekMisc     _{i +  5} \\
					+ & \peekMisc     _{i +  6} \\
					+ & \peekContext  _{i +  7} \\
				\end{array} \right] \\
				\locFlagSumModexpSuccess & \define &
				\left[ \begin{array}{cr}
					+ & \peekScenario _{i     } \\
					+ & \peekMisc     _{i +  1} \\
					+ & \peekMisc     _{i +  2}
					+   \peekMisc     _{i +  3}
					+   \peekMisc     _{i +  4} \\
					+ & \peekMisc     _{i +  5} \\
					+ & \peekMisc     _{i +  6} \\
					+ & \peekMisc     _{i +  7}
					+   \peekMisc     _{i +  8}
					+   \peekMisc     _{i +  9} \\
					+ & \peekMisc     _{i + 10} \\
					+ & \peekMisc     _{i + 11} \\
					+ & \peekContext  _{i + 12} \\
				\end{array} \right] \\
				\locNsrModexpFKTH    & \equiv  & \leftUndefined \\
				\locNsrModexpFKTR    & \define & 8              \\
				\locNsrModexpSuccess & \define & 13             \\
			\end{array} \right.
		\]
		In the above we have regrouped ``like-minded'' miscellaneous rows.
		The first set corresponds to the extraction of
		$\locBase$,
		$\locExponent$
		and $\locModulus$ (i.e. in the notations of the \oobMod{} module,
		\locBbs{},
		\locEbs{}
		and \locMbs{}.)
	\item[\underline{\underline{Shorthands for \instEcadd{}, \instEcmul{}, \instEcpairing{}, \blsDataMod{} precompiles and \instPVerify{}:}}]
		for
		\[
			\loc{xxx} \in \left\{
				\begin{array}{r}
				\loc{ecadd},                ~ \loc{ecmul},                ~ \loc{ecpairing}, \\
				\loc{point\_evaluation},                                                     \\
				\loc{bls\_g1\_add},         ~ \loc{bls\_g1\_msm},                            \\
				\loc{bls\_g2\_add},         ~ \loc{bls\_g2\_msm},                            \\
				\loc{bls\_pairing\_check},                                                   \\
				\loc{bls\_map\_fp\_to\_g1}, ~ \loc{bls\_map\_fp2\_to\_g2}                    \\
				\loc{p256\_verify},                                                          \\
				\end{array}
				\right\}
		\]
		we set
		\[
			\left\{ \begin{array}{lcl}
				\locFlagSumXxxFKTH    & \define & \locStandardFailureFlagSum \\
				\locFlagSumXxxFKTR    & \define & \locStandardFailureFlagSum \\
				\locFlagSumXxxSuccess & \define & \locStandardSuccessFlagSum \\
				\locNsrXxxFKTH        & \define & \locStandardFailureNsr     \\
				\locNsrXxxFKTR        & \define & \locStandardFailureNsr     \\
				\locNsrXxxSuccess     & \define & \locStandardSuccessNsr     \\
			\end{array} \right.
		\]
		\saNote{}
		Note~(\ref{hub: instruction handling: call: precompiles: flag sums and nsr II: the 2 distinct success scenarios for ECRECOVER})
		on the ``two fundamentally distinct `success' scenarios for \instEcrecover{}''
		applies with minor modification to \instPVerify{}, too.

		\saNote{}
		\instPVerify{}, like \instEcrecover{}, does not permit \scenPrcFailureKnownToRam{},
		see the definition of \scenPrecompileMayOnlyFailInHub{}
		in section~(\ref{hub: scenarios: shorthands: precompile})
		and the associated constraint
		in section~(\ref{hub: instruction handling: call: precompiles: generalities: admissible failure scenarios}).
		Yet, the above introduces two associated shorthands:
		\locFlagSumPVerifyFKTR{} and
		\locNsrPVerifyFKTR{}.
		These serve no purpose and won't see any actual use.
	\item[\underline{\underline{Shorthands for \instBlake{}:}}] the \instBlake{} precompile requires special care:
		\[
			\left\{ \begin{array}{lcl}
				\locFlagSumBlakeFKTH        & \define & \locStandardFailureFlagSum \\
				\locFlagSumBlakeFKTR        & \define &
				\left[ \begin{array}{cr}
					+ & \peekScenario _{i    } \\
					+ & \peekMisc     _{i + 1} \\
					+ & \peekMisc     _{i + 2} \\
					+ & \peekContext  _{i + 3} \\
				\end{array} \right] \\
				\locFlagSumBlakeSuccess     & \define &
				\left[ \begin{array}{cr}
					+ & \peekScenario _{i    } \\
					+ & \peekMisc     _{i + 1} \\
					+ & \peekMisc     _{i + 2} \\
					+ & \peekMisc     _{i + 3} \\
					+ & \peekMisc     _{i + 4} \\
					+ & \peekContext  _{i + 5} \\
				\end{array} \right] \\
				\locNsrBlakeFKTH    & \define & \locStandardFailureNsr \\
				\locNsrBlakeFKTR    & \define & 4                      \\
				\locNsrBlakeSuccess & \define & 6                      \\
			\end{array} \right.
		\]
\end{description}
\saNote{} \label{hub: instruction handling: call: precompiles: flag sums and nsr II: the prc scenario row is followed by a misc row}
\textbf{In all cases the first row after the scenario row $i$, i.e. row $i + 1$, is a miscellaneous-row.}
In fact there are either (depending on the precompile and the scenario)
1, 2, 3, 4, 6 or 11 consecutive miscellaneous-rows following the initial precompile scenario-row.
