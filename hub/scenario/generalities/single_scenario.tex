\begin{center}
	\boxed{\text{All constraints in this section are written under the assumption } \peekScenario_{i} = 1.}
\end{center}
We impose the following:
\begin{enumerate}[resume]
	\item Precisely one of the scenario flags is on each scenario-row:
		\[
			\left[ \begin{array}{cr}
				+ & \scenCallSum          _{i} \\
				+ & \scenCreateSum        _{i} \\
				+ & \scenPrecompileSum    _{i} \\
				+ & \scenReturnSum        _{i} \\
				+ & \scenSelfdestructSum  _{i} \\
			\end{array} \right]
			= 1
		\]
	\item Furthermore only one precompile scenario can be active
		\[
			\scenPrcScenarioSum_{i} = \scenPrecompileSum_{i}
		\]
\end{enumerate}
\saNote{} These binary constraints, in particular the final one, have implicit consequences. For one, all shorthands below (and many others \dots)are all \textbf{automatically} binary:
\begin{multicols}{2}
	\begin{itemize}
		\item $\scenCallSum_{i}$
		\item $\scenCallEntry_{i}$
		\item $\scenCallEoa_{i}$
		\item $\scenCallPrc_{i}$
		\item $\scenCallSmc_{i}$
		\item $\scenCallerWillRevert_{i}$
		\item $\scenCallSuccess_{i}$
		\item $\scenCreateSum_{i}$
		\item $\scenCreateSuccess_{i}$
		\item $\scenPrecompileSum_{i}$
		\item $\scenReturnSum_{i}$
		\item[\vspace{\fill}]
	\end{itemize}
\end{multicols}


