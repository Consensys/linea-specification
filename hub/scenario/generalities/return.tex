\begin{center}
	\boxed{\text{All constraints in this section are written under the assumption } \peekScenario_{i} = 1.}
\end{center}
In this section we impose general constraints on \textbf{scenario-columns}. We shall impose the following:
\begin{enumerate}
	\item The following columns satisfy a binary constraint \lispDone{}
		\begin{enumerate}
			\item \scenReturnFromMessageCallWillTouchRam{}
			\item \scenReturnFromMessageCallWontTouchRam{}
			\item \scenReturnFromDeploymentEmptyByteCodeWillRevert{}
			\item \scenReturnFromDeploymentEmptyByteCodeWontRevert{}
			\item \scenReturnFromDeploymentNonemptyByteCodeWillRevert{}
			\item \scenReturnFromDeploymentNonemptyByteCodeWontRevert{}
		\end{enumerate}
\end{enumerate}
These sums are further subject to the following constraint: 
\begin{enumerate}[resume]
	\item Precisely one of the scenario flags is on on each scenario-row:
		\[
			\left[ \begin{array}{cr}
				+ & \scenCallSum          _{i} \\
				+ & \scenCreateSum        _{i} \\
				+ & \scenReturnSum        _{i} \\
				+ & \scenPrecompileSum    _{i} \\
				+ & \scenSelfdestructSum  _{i} \\
			\end{array} \right]
			= 1
		\]
	\item Furthermore only one precompile scenario can be active
		\[
			\scenPrcScenarioSum_{i} = \scenPrecompileSum_{i}
		\]
\end{enumerate}
\saNote{} These binary constraints, in particular the final one, have implicit consequences. For one, all shorthands below
\begin{multicols}{2}
	\begin{itemize}
		\item $\scenCallSum_{i}$
		\item $\scenCallEntry_{i}$
		\item $\scenCallEoa_{i}$
		\item $\scenCallPrc_{i}$
		\item $\scenCallSmc_{i}$
		\item $\scenCallerWillRevert_{i}$
		\item $\scenCallSuccess_{i}$
		\item $\scenCreateSum_{i}$
		\item $\scenCreateSuccess_{i}$
		\item $\scenPrecompileSum_{i}$
		\item $\scenReturnSum_{i}$
		\item[\vspace{\fill}]
	\end{itemize}
\end{multicols}
are all \emph{automatically} binary.

