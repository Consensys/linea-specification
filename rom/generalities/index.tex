
\begin{enumerate}
	\item \If $\romColumnCfi _{i} = 0$ \Then $\romColumnLimbIndex _{i} =  0$
	\item \If $\romColumnCfi _{i} \neq \romColumnCfi _{i-1}$ \Then $\romColumnLimbIndex _{i} =  0$
	\item \If \Big($\romColumnCfi _{i} \neq 0$ \et $\romColumnCfi _{i} \neq \romColumnCfi _{i-1} + 1$ \et $\ct _{i} = 0$\Big) \Then:
		\[ \romColumnLimbIndex _{i} = \romColumnLimbIndex _{i-1}+1 \]
	\item \If $\ct _{i} = \llarge$ \Then $\romColumnLimbIndex _{i} = \romColumnLimbIndex _{i-1}+1$
	\item \If ($\ct _{i} \neq 0$ \et $\ct _{i} \neq \llarge$) \Then $\romColumnLimbIndex _{i} = \romColumnLimbIndex _{i-1}$
\end{enumerate}
\saNote{} The condition ``$\ct _{i} = \llarge$'' is only triggered in the zero-padding of bytecode that happens at the end of every code fragment tracing. This constraint imposes that the index grow by one at the expected row.

\saNote{} The requirement to add two full zero limbs at the end of the code fragment stems from two different reasons:
(\emph{a}) allowing for simple push value construction
(\emph{b}) making the lookup $\rlpTxnMod \hookrightarrow \romMod$ work seamlessly.
The former module indeed appends two padding limbs to the end of initialization code.
