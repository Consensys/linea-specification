We impose that \romColumnPadding{} equals $0$ while the \romColumnProgramCounter{} hasn't reached \romColumnCodeSize{}.
Once it does, we impose that \romColumnPadding{} increment to $1$ and stay there until the end of the current \cfi{}.
\begin{enumerate}
    \item we impose that \romColumnPadding{} be binary (\sanityCheck{}, see section~(\ref{rom: constraints: binarities});
    \item we impose that \romColumnPadding{} be \cfi-incrementing;
    \item \If $\romColumnProgramCounter _{i} = \romColumnCodeSize _{i} - 1$ \Then $\romColumnPadding _{i} + \romColumnPadding _{i + 1} = 1$
\end{enumerate}

Before \romColumnPadding{} switches to one,
we are given with \romColumnLimb{}
of $\llarge$ bytes,
therefore a $\llarge$ long \ct{}-loop.
After the \romColumnPadding{} switches to one, we want at least $\evmWordSize$ padded bytes after, in case the last opcode is a \inst{PUSH32}. 
\begin{enumerate}[resume]
    \item \If $\cfi _{i} \neq 0$ \et $\ct _{i} = 0$ \Then:
    \begin{enumerate}
        \item \If $\romColumnPadding _{i} = 0$ \Then $\ctMax _{i} = \llargeMO$
        \item \If $\romColumnPadding _{i} = 1$ \Then $\ctMax _{i} = \evmWordSizeMO$
    \end{enumerate}
\end{enumerate}
