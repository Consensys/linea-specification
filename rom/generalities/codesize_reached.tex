We impose that \CSR{} equals $0$ while the \pc{} hasn't reached \CS{}.
Once it does, we impose that \csr{} increment to $1$ and stay there until the end of the current \cfi{}.
\begin{enumerate}
    \item we impose that \CSR{} be binary (\sanityCheck{}, see section~(\ref{rom: constraints: binarities});
    \item we impose that \CSR{} be \cfi-incrementing;
    \item \If $\pc_{i} = \cs_{i} - 1$ \Then $\csr_{i} + \csr_{i + 1}=1$
\end{enumerate}

Before \CSR{} switches to one,
we are given with \limb{}
of $\llarge$ bytes,
therefore a $\llarge$ long \ct{}-loop.
After the \CSR{} switches to one, we want at least $\evmWordSize$ padded bytes after, in case the last opcode is a \inst{PUSH32}. 
\begin{enumerate}[resume]
    \item \If $\cfi_{i} \neq 0$ \et $\ct_{i}=0$ \Then:
    \begin{enumerate}
        \item \If $\CSR_{i}=0$ \Then $\ctMax_{i} = \llargeMO$
        \item \If $\CSR_{i}=1$ \Then $\ctMax_{i} = \evmWordSizeMO$
    \end{enumerate}
\end{enumerate}
