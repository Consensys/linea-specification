The \romMod{} module exposes and processes all pieces of (\textbf{nonempty}) byte code,
initialization codes and deployed byte codes alike,
required by the processing of a conflation of blocks.
Its main role in the overall design is to provide the \hubMod{} module with the correct sequence of instructions,
as well as related pieces of data.
In more detail, the present module
\textbf{performs jump destination analysis} and
\textbf{assembles \inst{PUSH}-values} from the bytes following a \inst{PUSHX} opcode,
for $\inst{X} \in \{ \inst{1}, \inst{2}, \dots, \evmWordSize \}$.
Note that \inst{PUSH0}, introduced in \cite{EYP-Shanghai} with \cite{EIP-3855}, is excluded from that list.
Most of the arithmetization below focuses on building the \romMod{} module as a seqence of padded byte codes and of extracting the correct push values from it (i.e. the $\inst{X}$-byte long arguments of actual \inst{PUSHX} instructions).

What follows is a complete list of events that trigger the \romMod{} module to incorporate byte code into its trace:
\begin{enumerate}
    \item
        \user{}-transaction processing whose $\loc{addr} \equiv \col{tx.toAddress()} \neq \varnothing$ has nonempty byte code;
        the \romMod{} module loads the byte code $\mathbf{b}$ from the state,
    where $\texttt{KECCAK}(\mathbf{b}) = \bm{\sigma}\big[ \loc{addr} \big]_c$;
    \item
        similarly for unexceptional \inst{CALL}'s, \inst{CALLCODE}'s, \inst{STATICCALL}'s and \inst{DELEGATECALL}'s into accounts with nonempty byte code;
    \item
        \user{}-transaction processing with $\loc{tx.toAddress()} = \varnothing$ and nonempty \loc{tx.payload()};
        the \romMod{} loads the initialization code $T_\mathbf{i} \equiv \loc{tx.payload()}$ from the \rlpTxnMod{} module;
    \item
        similarly when initiating deployments through (unexceptional, unaborted and no failure condition raising) \inst{CREATE(2)} instructions;
        the \romMod{} module similarly loads the initialization code from \textsc{ram}, i.e. from the \mmioMod{} module;
    \item
        for \emph{temporarily} successful deployments of
        nonempty byte code, the byte code is loaded into the \romMod{} from \textsc{ram}, i.e. from the \mmioMod{} module;
    \item
        for nontrivial and unexceptional \inst{EXTCODECOPY} operations targeting an account with nonempty byte code;
\end{enumerate}
\saNote{}
We add the qualifier \emph{temporarily} to deployments since successful deployments may get reverted later on in the same transaction.
