\[
	\boxed{\text{All constraints in this subsection assume that }
	\left\{ \begin{array}{lcl}
		\isMxpScenario                     _{i} & = & 1 \\
		\locMxpScenarioNonTrivialOperation _{i} & = & 1 \\
	\end{array} \right. }
\]
\noindent
The present section describes the computation for the $\locMxpScenarioNonTrivialOperation$ case.
We need the following constant:
\[
	\LMMS \define 256^4 
\]
\begin{description}
	\def\nRows{\yellowm{3}}\item[\underline{\underline{Testing for small-ness of first size argument:}}] 
		we impose that
		\[
			\wcpCallToLt{
				anchorRow = i               ,
				relOffset = \nRows          ,
				argOneHi  = \locSizeOneHi   ,
				argOneLo  = \locSizeOneLo   ,
				argTwoHi  = 0               ,
				argTwoLo  = \LMMS           ,
			}
		\]
		and we define the following shorthand
		\[
			\left\{ \begin{array}{lcl}
				\locSizeOneIsSmall    & \define & \mxpComputationResA _{i + \nRows} \\
				\locSizeOneIsLarge    & \define & 1 - \locSizeOneIsSmall            \\
			\end{array} \right.
		\]
	\def\nRows{\yellowm{4}}\item[\underline{\underline{Testing for small-ness of second size argument:}}] 
		we impose that
		\[
			\wcpCallToLt{
				anchorRow = i               ,
				relOffset = \nRows          ,
				argOneHi  = \locSizeTwoHi   ,
				argOneLo  = \locSizeTwoLo   ,
				argTwoHi  = 0               ,
				argTwoLo  = \LMMS           ,
			}
		\]
		and we define the following shorthand
		\[
			\left\{ \begin{array}{lcl}
				\locSizeTwoIsSmall    & \define & \mxpComputationResA _{i + \nRows} \\
				\locSizeTwoIsLarge    & \define & 1 - \locSizeTwoIsSmall            \\
			\end{array} \right.
		\]

	\def\nRows{\yellowm{5}}\item[\underline{\underline{Testing for small-ness of first offset argument:}}] 
		we impose that
		\[
			\wcpCallToLt{
				anchorRow = i               ,
				relOffset = \nRows          ,
				argOneHi  = \locOffsetOneHi ,
				argOneLo  = \locOffsetOneLo ,
				argTwoHi  = 0               ,
				argTwoLo  = \LMMS           ,
			}
		\]
		and we define the following shorthand
		\[
			\left\{ \begin{array}{lcl}
				\locOffsetOneIsSmall    & \define & \mxpComputationResA _{i + \nRows} \\
				\locOffsetOneIsLarge    & \define & 1 - \locOffsetOneIsSmall          \\
			\end{array} \right.
		\]
	\def\nRows{\yellowm{6}}\item[\underline{\underline{Testing for small-ness of second offset argument:}}] 
		we impose that
		\[
			\wcpCallToLt{
				anchorRow = i               ,
				relOffset = \nRows          ,
				argOneHi  = \locOffsetTwoHi ,
				argOneLo  = \locOffsetTwoLo ,
				argTwoHi  = 0               ,
				argTwoLo  = \LMMS           ,
			} 
		\]
		and we define the following shorthand
		\[
			\left\{ \begin{array}{lcl}
				\locOffsetTwoIsSmall    & \define & \mxpComputationResA _{i + \nRows} \\
				\locOffsetTwoIsLarge    & \define & 1 - \locOffsetTwoIsSmall          \\
			\end{array} \right.
		\]
	\item[\underline{\underline{Further justifying the scenario:}}]
		\label{mxp: computation: non trivial: justifying the mxpx scenario}
		we define the following shorthand:
		\[
			\left\{ \begin{array}{lcl}
				\locMxpComputationMxpxExpressionOne & \define & 
				\left[ \begin{array}{cl}
					+ & \locSizeOneIsLarge                              \\
					+ & \locSizeOneIsNonZero \cdot \locOffsetOneIsLarge \\
				\end{array} \right] \vspace{2mm} \\
				\locMxpComputationMxpxExpressionTwo & \define & 
				\left[ \begin{array}{cl}
					+ & \locSizeTwoIsLarge                              \\
					+ & \locSizeTwoIsNonZero \cdot \locOffsetTwoIsLarge \\
				\end{array} \right] \vspace{2mm} \\
				\locMxpComputationMxpxExpression & \define & 
				\left[ \begin{array}{cr}
					+ & \locMxpComputationMxpxExpressionOne \\
					+ & \locMxpComputationMxpxExpressionTwo \\
				\end{array} \right] \\
			\end{array} \right.
		\]
		and impose that
		\begin{enumerate}
			\item \If $\locMxpComputationMxpxExpression =    0$ \Then $\mxpScenarioMxpx _{i} = 0$
			\item \If $\locMxpComputationMxpxExpression \neq 0$ \Then $\mxpScenarioMxpx _{i} = 1$
		\end{enumerate}
\end{description}

\includepdf[fitpaper=true,pages={1}]{lua/nontrivial.pdf}
