\[
	\boxed{\text{All constraints in this subsection further assume } \oobInstIsModexpXbs_{i} = 1}
\]
The present instruction is used thrice within every single call to the \instModexp{} precompile.
With every invocation it checks whether the ``\locXbs'' byte size argument is $\leq \modexpMaxByteSizeName$ or not,
where
\[
	\modexpMaxByteSizeName \define \modexpMaxByteSizeValue
\]
It may also perform further computations if required.
We use the shorthands defined below:
\[
	\left\{ \begin{array}{lclr}
		\locXbsHi      & \define & \oobDataCol {1} _{i} \\
		\locXbsLo      & \define & \oobDataCol {2} _{i} \\
		\locYbsLo      & \define & \oobDataCol {3} _{i} \\
		\locComputeMax & \define & \oobDataCol {4} _{i} \\
	\end{array} \right.
	\quad\text{and}\quad
	\left\{ \begin{array}{lclr}
		\locMax          & \define & \oobDataCol {7}  _{i} & \prediction \\
		\locXbsNonzero   & \define & \oobDataCol {8}  _{i} & \prediction \\
		\locWithinBounds & \define & \oobDataCol {9}  _{i} & \prediction \\
		\locOutOfBounds  & \define & \oobDataCol {10} _{i} & \prediction \\
	\end{array} \right.
\]
\hubPredictionDecoratorBlurb{}

For the present instruction the \oobMod{} expects the value of \locComputeMax{} to be binary.
In applications the value of \locXbs{} is either \locBbs{}, \locEbs{} or \locMbs{}.
The first step is to compare \locXbs{} to $\modexpMaxByteSizeValue$.
If \locComputeMax{} is set we compute the maximum of \locYbsLo{} and \locXbs{}.
The use case for this comparison is to compute the maxium $\max\{ \locBbs, \locMbs \}$ as required by the pricing of the \instModexp{} precompile.
\begin{description}
	\item[\underline{Rows n°$(i)$, $n^\circ(i + 1)$ and $n^\circ(i + 2)$:}] we impose
		\[
			\left\{ \begin{array}{l}
				\wcpCallToLt {
					anchorRow = i                           ,
					relOffset = 0                           ,
					argOneHi  = \locXbsHi                   ,
					argOneLo  = \locXbsLo                   ,
					argTwoHi  = 0                           ,
					argTwoLo  = \modexpMaxByteSizeValue + 1 ,
				}
				\vspace{2mm} \\
				\wcpCallToLt {
					anchorRow = i         ,
					relOffset = 1         ,
					argOneHi  = 0         ,
					argOneLo  = \locXbsLo ,
					argTwoHi  = 0         ,
					argTwoLo  = \locYbsLo ,
				}
				\vspace{2mm} \\
				\wcpCallToIszero {
					anchorRow = i         ,
					relOffset = 2         ,
					argOneHi  = 0         ,
					argOneLo  = \locXbsLo ,
				}
			\end{array} \right.
		\]
		we further define the shorthands
		\[
			\left\{ \begin{array}{lcl}
				\locXbsIsLeqModexpMaxByteSize & \define & \outgoingResLo    _{i    }        \\
				\locXbsIsGtModexpMaxByteSize  & \define & 1 - \locXbsIsLeqModexpMaxByteSize \\
				\locResultOfComparison        & \define & \outgoingResLo    _{i + 1}        \\
			\end{array} \right.
		\]
		\saNote{} The value \locComputeMax{}, along with the other inputs, is provided to the \hubMod{} module and will be binary in all applications.

		\saNote{} The constraint $\outgoingResLo_{i} = 1$ enforces that the comparison ``$\locXbs < \modexpMaxByteSizeValue + 1$'' i.e. ``$\locXbs \leq \modexpMaxByteSizeValue$'' return \texttt{true}.
	\item[\underline{Justifying \hubMod{} predictions:}] we impose
		we further impose that
		\begin{enumerate}
			\item \locComputeMax{} is binary
			\item \If $\locComputeMax = \false$ \Then 
				\[
					\left\{ \begin{array}{lcl}
						\locMax        & = & 0 \\
						\locXbsNonzero & = & 0 \\
					\end{array} \right.
				\]
			\item \If $\locComputeMax = \true$ \Then
				\begin{enumerate}
					\item $\locXbsNonzero = 1 - \outgoingResLo_{i + 2}$
					\item \If $\locResultOfComparison = \false $ \Then $\locMax = \locXbsLo$
					\item \If $\locResultOfComparison = \true  $ \Then $\locMax = \locYbsLo$
				\end{enumerate}
			\item we set
				\[
					\left\{ \begin{array}{lcl}
						\locWithinBounds & = & \locXbsIsLeqModexpMaxByteSize \\
						\locOutOfBounds  & = & \locXbsIsGtModexpMaxByteSize  \\
					\end{array} \right.
				\]
		\end{enumerate}
\end{description}
