The present describes a contraint system that writes the \rlp{}-ization of a storage key.

We shall assume the following: we are provided with columns
\begin{itemize}
    \item $\col{input_1}$ and $\col{input_2}$: two 16 bytes columns;
    \item $\col{ct}$: a counter;
    \item $\col{ct_max}$: a column which specifies the size of the ct-loop;
    \item $\col{wcp_flag}$: a flag column;
    \item $\col{wcp_arg_1_hi}$, $\col{wcp_arg_1_lo}$, $\col{wcp_arg_2_hi}$, $\col{wcp_arg_2_lo}$: argument columns for the \wcpMod{} module;
    \item $\col{inst}$: a column containing the instruction;
    \item $\col{limb}$: a column where the output is written;
    \item $\col{lc}$: a bit column, is 1 when something is written in the $\col{limb}$, else 0;
    \item $\col{nBytes}$: number of meaningfull bytes of the $\col{limb}$;
\end{itemize}

\noindent We subsume under the short hand
\[
    \rlpStorageKey_{i}
    \left(
	\begin{array}{r}
    \col{input_1},
    \col{input_2},
    \col{ct},
    \col{ct_max}; \\
    \col{wcp_flag},
    \col{inst},
    \col{wcp_arg_1_hi},
    \col{wcp_arg_1_lo},
    \col{wcp_arg_2_hi},
    \col{wcp_arg_2_lo}; \\
    \col{limb},
    \col{lc},
    \col{nBytes}; \\
    \end{array}
	\right)
\]

\begin{enumerate}
    \item $\col{ct_max}_{i} = 2$
    \item $\col{wcp_flag}_{i} = 1$
    \item $\col{inst}_{i} = \inst{LEQ}$
    \item $\col{wcp_arg_1_hi}_{i} = \col{input_1}_{i}$
    \item $\col{wcp_arg_1_lo}_{i} = \col{input_2}_{i}$
    \item $\col{wcp_arg_2_hi}_{i} = (256 ^{\llarge} -1) $
    \item $\col{wcp_arg_2_lo}_{i} = (256 ^{\llarge} -1) $
    \item $\col{lc}_{i} = 1$
    \item $\col{limb}_{i}=\rlprefixStorage \cdot (256 ^{\llargeMO})$
    \item $\col{nBytes}_{i} = 1$
    \item $\col{limb}_{i+1}=\col{input_1}_{i}$
    \item $\col{nBytes}_{i+1} = \llarge $
    \item $\col{limb}_{i+2}=\col{input_2}_{i}$
    \item $\col{nBytes}_{i+2} = \llarge $
\end{enumerate}
