\begin{center}
    \boxed{\text{In all this section, it is assumed that $\phaseBeta _{i}=1$ \et $\isTxn _{i} =1$.}}
\end{center}

We use the following shorthand:
\[
    \left\{ \begin{array}{lcl}
        \locReplayProtection & \define & \rlpTxnCommonColumnReplayProtection _{i} \\
        \locChainId          & \define & \rlpTxnTransactionColumnChainId     _{i} \\
        \locYparity                & \define & \rlpTxnCommonColumnYparity          _{i} \\
    \end{array} \right.
\]

We first compute $\rlp(w)$ which is in $\locLtTilde$ only:

\begin{enumerate}
    \item $\limbBelongsToLtOnly {
            anchorRow = i ,
            relOffset = 1 ,
        }$
    \item we define a \locTwScalar{} shorthand for what the \cite{EYP-Shanghai} calls ``a scalar $T_\text{w}$'':
        \begin{enumerate}
            \item \If $\locReplayProtection = 0$ \Then $\locTwScalar = \unprotectedV + \locYparity$
            \item \If $\locReplayProtection = 1$ \Then $\locTwScalar = \protectedBaseV + 2 \cdot \locChainId + \locYparity$
        \end{enumerate}
    \item $\inputColumn{1} _{i + 1} = 0$
    \item
        \[
            \rlpInteger _{i}
            \left(
            \begin{array}{r}
                \inputColumn{1},
                \inputColumn{2},
                \ct,
                \maxCt; \\
                \rlpUtilsFlag,
                \INST,
                \outputColumn{1},
                \outputColumn{2},
                \outputColumn{3},
                \outputColumn{4},
                \outputColumn{5}; \\
                \limb,
                \lc,
                \limbsize; \\
            \end{array}
            \right)
        \]
    \item \If $\locReplayProtection = 0$ \Then:
        \begin{enumerate}
            \item $\inputColumn{2} _{i + 1} = \unprotectedV + \locYparity $
            \item $\phaseEnd _{i + \rlpIntegerInstNbRows} = 1$
        \end{enumerate}
    \item \If $\locReplayProtection = 1$ \Then:
        \begin{enumerate}
            \item $\inputColumn{2} _{i + 1} = 2 \cdot \locChainId + \locYparity$ 
            \item $\phaseEnd _{i + \rlpIntegerInstNbRows} = 0$
        \end{enumerate}
\end{enumerate}

In the case $\locReplayProtection = 1$ the phase stops here.
In the case $\locReplayProtection = 0$, we now compute the postfix of
$\locLxTilde$ which is $\mathtt{RLP}(\beta) \cdot \mathtt{RLP}(\varnothing) \cdot \mathtt{RLP}(\varnothing)$  where $\beta = ChainId$ is specified (equivalently $w \notin \{\unprotectedV , \unprotectedVPO \}$.)

\begin{enumerate}[resume]
    \item \If $\locReplayProtection = 0$ \Then:
        \begin{enumerate}
            \item
                $\limbBelongsToLxOnly {
                    anchorRow = i                     ,
                    relOffset = \rlpIntegerInstNbRows ,
                }$
            \item $\inputColumn{1} _{i + \rlpIntegerInstNbRows + 1} = 0$
            \item $\inputColumn{2} _{i + \rlpIntegerInstNbRows + 1} = \locChainId $
            \item
                \[
                    \rlpInteger _{i + \rlpIntegerInstNbRows + 1}
                    \left(
                    \begin{array}{r}
                        \inputColumn{1},
                        \inputColumn{2},
                        \ct,
                        \maxCt; \\
                        \rlpUtilsFlag,
                        \INST,
                        \outputColumn{1},
                        \outputColumn{2},
                        \outputColumn{3},
                        \outputColumn{4},
                        \outputColumn{5}; \\
                        \limb,
                        \lc,
                        \limbsize; \\
                    \end{array}
                    \right)
                \]
            \item $\phaseEnd _{i + \rlpIntegerInstNbRows + \rlpIntegerInstNbRows} = 0$
            \item
                $\limbBelongsToLxOnly {
                    anchorRow = i                                                 ,
                    relOffset = \rlpIntegerInstNbRows + \rlpIntegerInstNbRows + 1 ,
                }$

            \item $\limb     _{i + \rlpIntegerInstNbRows + \rlpIntegerInstNbRows + 1} = \rlprefixShortInt \cdot 256^{15} + \rlprefixShortInt \cdot 256^{14}$
            \item $\limbsize _{i + \rlpIntegerInstNbRows + \rlpIntegerInstNbRows + 1} = 2$ 
            \item $\phaseEnd _{i + \rlpIntegerInstNbRows + \rlpIntegerInstNbRows + 1} = 1$ 
        \end{enumerate}
\end{enumerate}
