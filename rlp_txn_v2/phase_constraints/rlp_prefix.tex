\begin{center}
	\boxed{\text{We assume that $\phaseRlpPrefix _{i} = 1$.}}
\end{center}

We unconditionally impose that
\begin{enumerate}
	\item $\ltByteSizeCountDown _{i} = \ltByteSizeCountDown _{i + 1}$
	\item $\lxByteSizeCountDown _{i} = \lxByteSizeCountDown _{i + 1}$
	\item $\maxCt    _{i} = 0$  \quad (\sanityCheck)
\end{enumerate}
\saNote{}
The initial value of \ltByteSizeCountDown{}
is the length of the \rlp{}-ization of the whole transaction \emph{minus}
the number of bytes of the global \rlp{} prefix itself and,
if applicable, the first byte encoding the transaction type.

\begin{center}
	\boxed{\text{From now on we assume that }
	\left\{ \begin{array}{lcl}
		\phaseRlpPrefix _{i} & = & \true \\
		\isTxn          _{i} & = & \true \\
	\end{array} \right.
	}
\end{center}
We first determine the $\transactionType$ prefix concatenation on the first row:
\begin{description}
		\def\locRowOffset{\yellowm{1}}
	\item[\underline{\underline{Computation row $n^°\locRowOffset$:}} \underline{transaction type prefix:}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToBothLtAndLx {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item \If $\typeZeroTx _{i + \locRowOffset} = \true$ \Then
				\[
					\discardLimb {
						anchorRow = i             ,
						relOffset = \locRowOffset ,
					}
				\]
			\item \If $\typeZeroTx _{i + \locRowOffset} = \false$ \Then
				\[
					\setLimb{
						anchorRow = i                                                         ,
						relOffset = \locRowOffset                                             ,
						limb      = \rlpTxnTransactionColumnTxType _{i} \cdot 256^{\llargeMO} ,
						nBytes    = 1                                                         ,
					}
				\]
			\item $\phaseEnd _{i + \locRowOffset} = \false$
		\end{enumerate}
		\def\locRowOffset{\yellowm{2}}
	\item[\underline{\underline{Computation row $n^°\locRowOffset$:}} \underline{global prefix for $\locLtTilde$}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToLtOnly {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item 
				we impose
				\[
					\rlpProcessByteString {
						anchorRow        = i                            ,
						relOffset        = \locRowOffset                ,
						byteStringLength = \ltByteSizeCountDown _{i}    ,
						firstByte        = \nothing                     ,
						isList           = \true                        ,
						mustBeNontrivial = \true                        ,
					}
				\]
				and we define the following shorthands
				\[
					\left\{ \begin{array}{lcl}
						\locLtHasRlpPrefix         & \define & \rlpTxnComputationColumnExoDataColumn{4} _{i + \locRowOffset} \\
						\locLtRlpPrefix            & \define & \rlpTxnComputationColumnExoDataColumn{5} _{i + \locRowOffset} \\
						\locLtByteStringIsNonempty & \define & \rlpTxnComputationColumnExoDataColumn{6} _{i + \locRowOffset} \\
						\locLtRlpPrefixByteSize    & \define & \rlpTxnComputationColumnExoDataColumn{8} _{i + \locRowOffset} \\
					\end{array} \right.
				\]
				\saNote{}
				There is no need to specify the first byte of the byte string of which we are computing the \rlp{}-prefix:
				that string is necessarily longer than $1$ byte, and thus its first byte is irrelevant.
			% \item
			% 	we impose
			% 	\[
			% 		\setLimb {
			% 			anchorRow = i                       ,
			% 			relOffset = \locRowOffset           ,
			% 			limb      = \locLtRlpPrefix         ,
			% 			nBytes    = \locLtRlpPrefixByteSize ,
			% 		}
			% 	\]
			% \item
			% 	the following are non essential sanity checks:
			% 	\[
			% 		\left\{ \begin{array}{lclr}
			% 			\locLtHasRlpPrefix         & = & 1 & (\sanityCheck) \\
			% 			\locLtByteStringIsNonempty & = & 1 & (\sanityCheck) \\
			% 		\end{array} \right.
			% 	\]
			\item $\phaseEnd _{i + \locRowOffset} = \false$
		\end{enumerate}
		\def\locRowOffset{\yellowm{3}}
	\item[\underline{\underline{Computation row $n^°\locRowOffset$:}} \underline{global prefix for $\locLxTilde$}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToLxOnly {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item 
				we impose
				\[
					\rlpProcessByteString {
						anchorRow        = i                         ,
						relOffset        = \locRowOffset             ,
						byteStringLength = \lxByteSizeCountDown _{i} ,
						firstByte        = \nothing                  ,
						isList           = 1                         ,
						mustBeNontrivial = \true                     ,
					}
				\]
				and we define the following shorthands
				\[
					\left\{ \begin{array}{lcl}
						\locLxHasRlpPrefix         & \define & \rlpTxnComputationColumnExoDataColumn{4} _{i + \locRowOffset} \\
						\locLxRlpPrefix            & \define & \rlpTxnComputationColumnExoDataColumn{5} _{i + \locRowOffset} \\
						\locLxByteStringIsNonempty & \define & \rlpTxnComputationColumnExoDataColumn{6} _{i + \locRowOffset} \\
						\locLxRlpPrefixByteSize    & \define & \rlpTxnComputationColumnExoDataColumn{8} _{i + \locRowOffset} \\
					\end{array} \right.
				\]
				\saNote{}
				There is no need to specify the first byte of the byte string of which we are computing the \rlp{}-prefix:
				that string is necessarily longer than $1$ byte, and thus its first byte is irrelevant.
			% \item
			% 	we impose
			% 	\[
			% 		\setLimb {
			% 			anchorRow = i                       ,
			% 			relOffset = \locRowOffset           ,
			% 			limb      = \locLxRlpPrefix         ,
			% 			nBytes    = \locLxRlpPrefixByteSize ,
			% 		}
			% 	\]
			% \item
			% 	the following are non essential sanity checks:
			% 	\[
			% 		\left\{ \begin{array}{lclr}
			% 			\locLxHasRlpPrefix         & = & 1 & (\sanityCheck) \\
			% 			\locLxByteStringIsNonempty & = & 1 & (\sanityCheck) \\
			% 		\end{array} \right.
			% 	\]
			\item $\phaseEnd _{i + \locRowOffset} = \true$
		\end{enumerate}
\end{description}

