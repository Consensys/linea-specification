\begin{center}
	\boxed{\text{We assume that $\phaseRlpPrefix _{i} = 1$.}}
\end{center}

We unconditionally impose that
\begin{enumerate}
	\item $\rlptsize _{i} = \rlptsize _{i + 1}$
	\item $\rlpxsize _{i} = \rlpxsize _{i + 1}$
	\item $\maxCt    _{i} = 0$
\end{enumerate}
\saNote{}
The initial value of \rlptsize{}
is the length of the \rlp{}-ization of the whole transaction \emph{minus}
the number of bytes of the global \rlp{} prefix itself and,
if applicable, the first byte encoding the transaction type.

\begin{center}
	\boxed{\text{From now on we assume that $
	\left\{ \begin{array}{lcl}
		\phaseRlpPrefix _{i} & = & 1 \\
		\isTxn          _{i} & = & 1 \\
	\end{array} \right.
	$.}}
\end{center}
We first determine the $\transactionType$ prefix concatenation on the first row:
\begin{description}
		\def\locRowOffset{\yellowm{1}}
	\item[\underline{Computation row $n^°\locRowOffset$:} \underline{transaction type prefix:}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToBothLtAndLx {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item \If $\typeZeroTx _{i + \locRowOffset} =    0$ \Then
				\[
					\discardLimb {
						anchorRow = i             ,
						relOffset = \locRowOffset ,
					}
				\]
			\item \If $\typeZeroTx _{i + \locRowOffset} \neq 0$ \Then
				\[
					\setLimb{
						anchorRow = i                                                         ,
						relOffset = \locRowOffset                                             ,
						limb      = \rlpTxnTransactionColumnTxType _{i} \cdot 256^{\llargeMO} ,
						nBytes    = 1                                                         ,
					}
				\]
			\item $\phaseEnd _{i + \locRowOffset} = 0$
		\end{enumerate}
		\def\locRowOffset{\yellowm{2}}
	\item[\underline{Computation row $n^°\locRowOffset$:} \underline{global prefix for $\locLtTilde$}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToLtOnly {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item 
				we impose
				\[
					\rlpUtilsInstCallByteStringPrefix {
						anchorRow        = i                 ,
						relOffset        = \locRowOffset     ,
						byteStringLength = \rlptsize _{i}    ,
						firstByte        = \nothing          ,
						isList           = 1                 ,
					}
				\]
				and we define the following shorthands
				\[
					\left\{ \begin{array}{lcl}
						\locLtHasRlpPrefix         & \define & \exoDataColumn{4} _{i + \locRowOffset} \\
						\locLtRlpPrefix            & \define & \exoDataColumn{5} _{i + \locRowOffset} \\
						\locLtByteStringIsNonempty & \define & \exoDataColumn{6} _{i + \locRowOffset} \\
						\locLtRlpPrefixByteSize    & \define & \exoDataColumn{8} _{i + \locRowOffset} \\
					\end{array} \right.
				\]
				\saNote{}
				There is no need to specify the first byte of the byte string of which we are computing the \rlp{}-prefix:
				that string is necessarily longer than $1$ byte, and thus its first byte is irrelevant.
			\item
				we impose
				\[
					\setLimb {
						anchorRow = i                       ,
						relOffset = \locRowOffset           ,
						limb      = \locLtRlpPrefix         ,
						nBytes    = \locLtRlpPrefixByteSize ,
					}
				\]
			\item
				the following are non essential sanity checks:
				\[
					\left\{ \begin{array}{lclr}
						\locLtHasRlpPrefix         & = & 1 & (\sanityCheck) \\
						\locLtByteStringIsNonempty & = & 1 & (\sanityCheck) \\
					\end{array} \right.
				\]
			% \item
			% 	\[
			% 		\rlpBytestringPrefix _{i + \locRowOffset}
			% 		\left(
			% 		\begin{array}{r}
			% 			\exoDataColumn{1},
			% 			\exoDataColumn{2},
			% 			\exoDataColumn{3},
			% 			\ct,
			% 			\maxCt; \\
			% 			\rlpUtilsFlag,
			% 			\INST,
			% 			\exoDataColumn{4},
			% 			\exoDataColumn{5},
			% 			\exoDataColumn{8}; \\
			% 			\limb,
			% 			\lc,
			% 			\limbsize; \\
			% 		\end{array}
			% 		\right)
			% 	\]
			\item $\phaseEnd _{i + \locRowOffset} = 0$
		\end{enumerate}
		\def\locRowOffset{\yellowm{3}}
	\item[\underline{Computation row $n^°\locRowOffset$:} \underline{global prefix for $\locLxTilde$}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToLxOnly {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item 
				we impose
				\[
					\rlpUtilsInstCallByteStringPrefix {
						anchorRow        = i                 ,
						relOffset        = \locRowOffset     ,
						byteStringLength = \rlpxsize _{i}    ,
						firstByte        = \nothing          ,
						isList           = 1                 ,
					}
				\]
				and we define the following shorthands
				\[
					\left\{ \begin{array}{lcl}
						\locLxHasRlpPrefix         & \define & \exoDataColumn{4} _{i + \locRowOffset} \\
						\locLxRlpPrefix            & \define & \exoDataColumn{5} _{i + \locRowOffset} \\
						\locLxByteStringIsNonempty & \define & \exoDataColumn{6} _{i + \locRowOffset} \\
						\locLxRlpPrefixByteSize    & \define & \exoDataColumn{8} _{i + \locRowOffset} \\
					\end{array} \right.
				\]
				\saNote{}
				There is no need to specify the first byte of the byte string of which we are computing the \rlp{}-prefix:
				that string is necessarily longer than $1$ byte, and thus its first byte is irrelevant.
			\item
				we impose
				\[
					\setLimb {
						anchorRow = i                       ,
						relOffset = \locRowOffset           ,
						limb      = \locLxRlpPrefix         ,
						nBytes    = \locLxRlpPrefixByteSize ,
					}
				\]
			\item
				the following are non essential sanity checks:
				\[
					\left\{ \begin{array}{lclr}
						\locLxHasRlpPrefix         & = & 1 & (\sanityCheck) \\
						\locLxByteStringIsNonempty & = & 1 & (\sanityCheck) \\
					\end{array} \right.
				\]
			% \item 
			% 	\[
			% 		\rlpBytestringPrefix _{i + \locRowOffset}
			% 		\left(
			% 		\begin{array}{r}
			% 			\exoDataColumn{1},
			% 			\exoDataColumn{2},
			% 			\exoDataColumn{3},
			% 			\ct,
			% 			\maxCt; \\
			% 			\rlpUtilsFlag,
			% 			\INST,
			% 			\exoDataColumn{4},
			% 			\exoDataColumn{5},
			% 			\exoDataColumn{8}; \\
			% 			\limb,
			% 			\lc,
			% 			\limbsize; \\
			% 		\end{array}
			% 		\right)
			% 	\]
			\item $\phaseEnd _{i + \locRowOffset} = 1$
		\end{enumerate}
\end{description}

