\begin{center}
	\boxed{\text{We assume that $\phaseRlpPrefix _{i} = 1$.}}
\end{center}

We unconditionally impose that
\begin{enumerate}
	\item $\ltByteSizeCountdown _{i} = \ltByteSizeCountdown _{i + 1}$
	\item $\lxByteSizeCountdown _{i} = \lxByteSizeCountdown _{i + 1}$
	\item $\maxCt    _{i} = 0$  \quad (\sanityCheck)
\end{enumerate}
\saNote{}
The initial value of \ltByteSizeCountdown{}
is the length of the \rlp{}-ization of the whole transaction \emph{minus}
the number of bytes of the global \rlp{} prefix itself and,
if applicable, the first byte encoding the transaction type.

\begin{center}
	\boxed{\text{From now on we assume that }
	\left\{ \begin{array}{lcl}
		\phaseRlpPrefix _{i} & = & \true \\
		\isTxn          _{i} & = & \true \\
	\end{array} \right.
	}
\end{center}
We first determine the $\transactionType$ prefix concatenation on the first row:
\begin{description}
		\def\locRowOffset{\yellowm{1}}
	\item[\underline{\underline{Computation row $n^°\locRowOffset$:}} \underline{transaction type prefix:}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToBothLtAndLx {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item \If $\typeZeroTx _{i + \locRowOffset} = \true$ \Then
				\[
					\discardLimb {
						anchorRow = i             ,
						relOffset = \locRowOffset ,
					}
				\]
			\item \If $\typeZeroTx _{i + \locRowOffset} = \false$ \Then
				\[
					\setLimb{
						anchorRow = i                                                         ,
						relOffset = \locRowOffset                                             ,
						limb      = \rlpTxnTransactionColumnTxType _{i} \cdot 256^{\llargeMO} ,
						nBytes    = 1                                                         ,
					}
				\]
			\item $\phaseEnd _{i + \locRowOffset} = \false$
		\end{enumerate}
		\def\locRowOffset{\yellowm{2}}
	\item[\underline{\underline{Computation row $n^°\locRowOffset$:}} \underline{global prefix for $\locLtTilde$}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToLtOnly {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item 
				we impose
				\[
					\rlpProcessByteString {
						anchorRow        = i                            ,
						relOffset        = \locRowOffset                ,
						byteStringLength = \ltByteSizeCountdown _{i}    ,
						firstByte        = \nothing                     ,
						isList           = \true                        ,
						mustBeNontrivial = \true                        ,
					}
				\]
				and we define the following shorthands
				\saNote{}
				There is no need to specify the first byte of the byte string of which we are computing the \rlp{}-prefix:
				that string is necessarily longer than $1$ byte, and thus its first byte is irrelevant.
			\item $\phaseEnd _{i + \locRowOffset} = \false$
		\end{enumerate}
		\def\locRowOffset{\yellowm{3}}
	\item[\underline{\underline{Computation row $n^°\locRowOffset$:}} \underline{global prefix for $\locLxTilde$}] 
		we impose
		\begin{enumerate}
			\item
				$
				\limbBelongsToLxOnly {
					anchorRow = i             ,
					relOffset = \locRowOffset ,
				}
				$
			\item 
				we impose
				\[
					\rlpProcessByteString {
						anchorRow        = i                         ,
						relOffset        = \locRowOffset             ,
						byteStringLength = \lxByteSizeCountdown _{i} ,
						firstByte        = \nothing                  ,
						isList           = \true                     ,
						mustBeNontrivial = \true                     ,
					}
				\]
				\saNote{}
				There is no need to specify the first byte of the byte string of which we are computing the \rlp{}-prefix:
				that string is necessarily longer than $1$ byte, and thus its first byte is irrelevant.
			\item $\phaseEnd _{i + \locRowOffset} = \true$
		\end{enumerate}
\end{description}

