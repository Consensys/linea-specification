\begin{center}
	\boxed{\text{Throughout this section it is assumed that $\phaseAccessList_{i}=1$.}}
\end{center}

We use the following shorthand:
\[
	\left\{ \begin{array}{lcl}
		\locPhaseSize                    _{i} & \define & \tmpData{1}_{i} \\
		\locTotNbOfAddress               _{i} & \define & \tmpData{2}_{i} \\
		\locTotNbOfStorage               _{i} & \define & \tmpData{3}_{i} \\
		\locAccessListTupleSize          _{i} & \define & \tmpData{4}_{i} \\
		\locAddressHi                    _{i} & \define & \tmpData{5}_{i} \\
		\locAddressLo                    _{i} & \define & \tmpData{6}_{i} \\
		\locTotStorageForThisAddress     _{i} & \define & \tmpData{7}_{i} \\
	\end{array} \right.
\]

We impose some generalities:
\begin{enumerate}
	\item
		$
		\limbBelongsToBothLtAndLx {
			anchorRow = i ,
			relOffset = 0 ,
		}
		$
\end{enumerate}

We prove some values of the transaction row:
\begin{enumerate}[resume]
	\item \If $\isTxn_{i-1}=0$ \Then
		\begin{enumerate}
			\item $\nbWarmedAddress_{i-1} = \locTotNbOfAddress_{i}$
			\item $\nbWarmedStorageKey_{i-1} = \locTotNbOfStorage_{i}$
		\end{enumerate}
\end{enumerate}
eit
We first determine the RLP prefix of the data on the first row:
\begin{enumerate}[resume]
	\item \If $\isTxn_{i-1}=1$ \Then
		\begin{enumerate}
			\item $\isPrefix _{i} = 1$
			\item $\isAddr   _{i} = 0$
			\item $\isSto    _{i} = 0$
			\item $\exoDataColumn{1}_{i} = \locPhaseSize_{i}$
			\item $\exoDataColumn{3}_{i} = 1$
			\item
				\[
					\rlpBytestringPrefix_{i}
					\left(
					\begin{array}{r}
						\exoDataColumn{1},
						\exoDataColumn{2},
						\exoDataColumn{3},
						\ct,
						\maxCt; \\
						\rlpUtilsFlag,
						\INST,
						\exoDataColumn{4},
						\exoDataColumn{5},
						\exoDataColumn{8}; \\
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
			\item $\phaseEnd_{i} = \exoDataColumn{6}_{i}$
			\item \If $\phaseEnd_{i} =0$ \Then:
				\begin{enumerate}
					\item $\isPrefix _{i+1} = 1$
					\item $\isAddr   _{i+1} = 1$
					\item $\isSto    _{i+1} = 0$
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

An access list tuple always starts with the rlp prefix of the tuple, followed by the RLP of an address:
\begin{enumerate}[resume]
	\item \If $\isPrefix_{i} = 1$ \et $\isAddr_{i} = 1$ \et $\isSto_{i} = 0$ Then:
		\begin{enumerate}
			\item $\exoDataColumn{1}_{i} = \locAccessListTupleSize_{i}$
			\item $\exoDataColumn{3}_{i} = 1$
			\item
				\[
					\rlpBytestringPrefix_{i}
					\left(
					\begin{array}{r}
						\exoDataColumn{1},
						\exoDataColumn{2},
						\exoDataColumn{3},
						\ct,
						\maxCt; \\
						\rlpUtilsFlag,
						\INST,
						\exoDataColumn{4},
						\exoDataColumn{5},
						\exoDataColumn{8}; \\
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
			\item $\isPrefix _{i+1} = 0$
			\item $\isAddr   _{i+1} = 1$
			\item $\isSto    _{i+1} = 0$
			\item
				\[
					\rlpAddress_{i+1}
					\left(
					\begin{array}{r}
						\locAddressHi,
						\locAddressLo,
						\ct,
						\maxCt; \\
						\trmFlag,
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
		\end{enumerate}

		After the RLP of an address, we have the RLP of the list of the (possibly empty) list of storage keys:
		\begin{enumerate}[resume]
			\item \If $\isPrefix_{i-1} = 0$ \et $\isAddr_{i-1} = 1$ \et $\isSto_{i-1} = 0$ \et $\done_{i-1} =1$ Then:
				\begin{enumerate}
					\item $\isPrefix _{i} = 1$
					\item $\isAddr   _{i} = 0$
					\item $\isSto    _{i} = 1$
					\item $\exoDataColumn{1}_{i} = 33 \cdot \locTotStorageForThisAddress_{i}$
					\item
						\[
							\rlpBytestringPrefix_{i}
							\left(
							\begin{array}{r}
								\exoDataColumn{1},
								\exoDataColumn{2},
								\exoDataColumn{3},
								\ct,
								\maxCt; \\
								\rlpUtilsFlag,
								\INST,
								\exoDataColumn{4},
								\exoDataColumn{5},
								\exoDataColumn{8}; \\
								\limb,
								\lc,
								\limbsize; \\
							\end{array}
							\right)
						\]

					\item \If $\exoDataColumn{6}_{i} = 1$ \Then:
						\begin{enumerate}
							\item $\isPrefix _{i+1} = 0$
							\item $\isAddr   _{i+1} = 0$
							\item $\isSto    _{i+1} = 1$
						\end{enumerate}

					\item \If $\exoDataColumn{6}_{i} = 0$ \et $\locTotNbOfAddress_{i} \neq 0$ \Then:
						\begin{enumerate}
							\item $\isPrefix _{i+1} = 1$
							\item $\isAddr   _{i+1} = 1$
							\item $\isSto    _{i+1} = 0$
						\end{enumerate}

					\item \If $\exoDataColumn{6}_{i} = 0$ \et $\locTotNbOfAddress_{i} = 0$ \Then:
						\begin{enumerate}
							\item $\phaseEnd _{i} = 1$
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}

		Here we constraint what happens when we have to do the RLP of a storage key:
		\begin{enumerate}[resume]
			\item \If $\isPrefix_{i-1} = 0$ \et $\isAddr_{i-1} = 0$ \et $\isSto_{i-1} = 1$ \et $\done_{i-1} =1$ Then:
				\begin{enumerate}
					\item $\exoDataColumn{1}_{i} = \exoDataColumn{1}_{i+1} = \exoDataColumn{1}_{i+2}$
					\item $\exoDataColumn{2}_{i} = \exoDataColumn{2}_{i+1} = \exoDataColumn{2}_{i+2}$
					\item \[
							\rlpStorageKey_{i}
							\left(
							\begin{array}{r}
								\exoDataColumn{1},
								\exoDataColumn{2},
								\ct,
								\maxCt; \\
								\rlpUtilsFlag,
								\INST; \\
								\limb,
								\lc,
								\limbsize; \\
							\end{array}
							\right)
						\]
				\end{enumerate}
		\end{enumerate}
		And the possibilities after the RLP of a storage key:
		\begin{enumerate}[resume]
			\item \If $\isPrefix_{i} = 0$ \et $\isAddr_{i} = 0$ \et $\isSto_{i} = 1$ \et $\done_{i} =1$ \Then:
				\begin{enumerate}
					\item \If $\locTotStorageForThisAddress_{i} \neq 0$ \Then: $\isPrefix_{i+1} = 0$ \et $\isAddr_{i+1} = 0$ \et $\isSto_{i+1} = 1$
					\item \If $\locTotStorageForThisAddress_{i} = 0$ \Then:
						\begin{enumerate}
							\item $\locAccessListTupleSize_{i} = 0$
							\item \If $\locTotNbOfAddress_{i} \neq 0$ \Then: $\isPrefix_{i+1} = 1$ \et $\isAddr_{i+1} = 1$ \et $\isSto_{i+1} = 0$
							\item \If $\locTotNbOfAddress_{i} = 0$ \Then: $\phaseEnd_{i} =1$
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}

		We constraint finalize the phase before the end by imposing:
		\begin{enumerate}
			\item \If $\phaseEnd_{i} =1$ \Then:
				\begin{enumerate}
					\item $\locPhaseSize_{i} =0$
					\item $\locTotNbOfAddress_{i} =0$
					\item $\locTotNbOfStorage_{i} =0$
				\end{enumerate}
		\end{enumerate}

		And some constancies properties:
		\begin{enumerate}
			\item $\locPhaseSize_{i} = \locPhaseSize_{i-1} - \lc_{i} \cdot \limbsize_{i}$
			\item \If $\isSto_{i} =1$ \Or ($\isAddr_{i} =1$ \et $\isPrefix_{i} =0$) \Then: $\locAccessListTupleSize_{i} = \locAccessListTupleSize_{i-1} - \lc_{i} \cdot \limbsize_{i}$
			\item $\locTotNbOfAddress_{i} = \locTotNbOfAddress_{i-1} - \isPrefix_{i} \cdot \isAddr_{i}$
			\item \If $\isAddr_{i} =1$ \et $\isSto_{i}=1$ \et $\locTotNbOfAddress_{i} = \locTotNbOfAddress_{i+1}$ \Then:
				\begin{enumerate}
					\item $\locAddressHi_{i} = \locAddressHi_{i+1}$
					\item $\locAddressLo_{i} = \locAddressLo_{i+1}$
				\end{enumerate}
			\item $\locTotNbOfStorage_{i} = \locTotNbOfStorage_{i} - \done_{i+2} \cdot \isSto_{i+2} \cdot (1 - \isPrefix_{i+2})$
			\item \If ($\isPrefix_{i} =1$ \et $\isAddr_{i} =1$) \Then: $\locTotStorageForThisAddress_{i} = \locTotStorageForThisAddress_{i} - \done_{i+2} \cdot \isSto_{i+2} \cdot (1 - \isPrefix_{i+2})$
		\end{enumerate}
	\end{enumerate}
