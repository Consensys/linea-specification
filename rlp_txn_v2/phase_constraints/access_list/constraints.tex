\begin{center}
	\boxed{\text{Throughout this section it is assumed that $\phaseAccessList _{i} = 1$.}}
\end{center}
An access list tuple always starts with the \rlp{} prefix of the tuple, followed by the \rlp{} of an address:
\begin{enumerate}[resume]
	\item \If $\isPrefix _{i} = 1$ \et $\isAddr _{i} = 1$ \et $\isSto _{i} = 0$ Then:
		\begin{enumerate}
			\item $\exoDataColumn{1} _{i} = \locAccessListTupleSize _{i}$
			\item $\exoDataColumn{3} _{i} = 1$
			\item
				\[
					\rlpBytestringPrefix _{i}
					\left(
					\begin{array}{r}
						\exoDataColumn{1},
						\exoDataColumn{2},
						\exoDataColumn{3},
						\ct,
						\maxCt; \\
						\rlpUtilsFlag,
						\INST,
						\exoDataColumn{4},
						\exoDataColumn{5},
						\exoDataColumn{8}; \\
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
			\item $\isPrefix _{i + 1} = 0$
			\item $\isAddr   _{i + 1} = 1$
			\item $\isSto    _{i + 1} = 0$
			\item
				\[
					\rlpAddress _{i + 1}
					\left(
					\begin{array}{r}
						\locAddressHi,
						\locAddressLo,
						\ct,
						\maxCt; \\
						\trmFlag,
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
		\end{enumerate}

		After the \rlp{} of an address, we have the \rlp{} of the list of the (possibly empty) list of storage keys:
		\begin{enumerate}[resume]
			\item \If $\isPrefix _{i - 1} = 0$ \et $\isAddr _{i - 1} = 1$ \et $\isSto _{i - 1} = 0$ \et $\done _{i - 1} =1$ Then:
				\begin{enumerate}
					\item $\isPrefix _{i} = 1$
					\item $\isAddr   _{i} = 0$
					\item $\isSto    _{i} = 1$
					\item $\exoDataColumn{1} _{i} = 33 \cdot \locTotStorageForThisAddress _{i}$
					\item
						\[
							\rlpBytestringPrefix _{i}
							\left(
							\begin{array}{r}
								\exoDataColumn{1},
								\exoDataColumn{2},
								\exoDataColumn{3},
								\ct,
								\maxCt; \\
								\rlpUtilsFlag,
								\INST,
								\exoDataColumn{4},
								\exoDataColumn{5},
								\exoDataColumn{8}; \\
								\limb,
								\lc,
								\limbsize; \\
							\end{array}
							\right)
						\]

					\item \If $\exoDataColumn{6} _{i} = 1$ \Then:
						\begin{enumerate}
							\item $\isPrefix _{i + 1} = 0$
							\item $\isAddr   _{i + 1} = 0$
							\item $\isSto    _{i + 1} = 1$
						\end{enumerate}

					\item \If $\exoDataColumn{6} _{i} = 0$ \et $\locAddressPrewarmingCountdown _{i} \neq 0$ \Then:
						\begin{enumerate}
							\item $\isPrefix _{i + 1} = 1$
							\item $\isAddr   _{i + 1} = 1$
							\item $\isSto    _{i + 1} = 0$
						\end{enumerate}

					\item \If $\exoDataColumn{6} _{i} = 0$ \et $\locAddressPrewarmingCountdown _{i} = 0$ \Then:
						\begin{enumerate}
							\item $\phaseEnd _{i} = 1$
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}

		Here we constraint what happens when we have to do the \rlp{} of a storage key:
		\begin{enumerate}[resume]
			\item \If $\isPrefix _{i - 1} = 0$ \et $\isAddr _{i - 1} = 0$ \et $\isSto _{i - 1} = 1$ \et $\done _{i - 1} =1$ Then:
				\begin{enumerate}
					\item $\exoDataColumn{1} _{i} = \exoDataColumn{1} _{i + 1} = \exoDataColumn{1} _{i + 2}$
					\item $\exoDataColumn{2} _{i} = \exoDataColumn{2} _{i + 1} = \exoDataColumn{2} _{i + 2}$
					\item \[
							\rlpStorageKey _{i}
							\left(
							\begin{array}{r}
								\exoDataColumn{1},
								\exoDataColumn{2},
								\ct,
								\maxCt; \\
								\rlpUtilsFlag,
								\INST; \\
								\limb,
								\lc,
								\limbsize; \\
							\end{array}
							\right)
						\]
				\end{enumerate}
		\end{enumerate}
		And the possibilities after the \rlp{} of a storage key:
		\begin{enumerate}[resume]
			\item \If $\isPrefix _{i} = 0$ \et $\isAddr _{i} = 0$ \et $\isSto _{i} = 1$ \et $\done _{i} =1$ \Then:
				\begin{enumerate}
					\item \If $\locTotStorageForThisAddress _{i} \neq 0$ \Then: $\isPrefix _{i + 1} = 0$ \et $\isAddr _{i + 1} = 0$ \et $\isSto _{i + 1} = 1$
					\item \If $\locTotStorageForThisAddress _{i} = 0$ \Then:
						\begin{enumerate}
							\item $\locAccessListTupleSize _{i} = 0$
							\item \If $\locAddressPrewarmingCountdown _{i} \neq 0$ \Then: $\isPrefix _{i + 1} = 1$ \et $\isAddr _{i + 1} = 1$ \et $\isSto _{i + 1} = 0$
							\item \If $\locAddressPrewarmingCountdown _{i} = 0$ \Then: $\phaseEnd _{i} =1$
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}

		We constraint finalize the phase before the end by imposing:
		\begin{enumerate}
			\item \If $\phaseEnd _{i} =1$ \Then:
				\begin{enumerate}
					\item $\locPhaseSize _{i} =0$
					\item $\locAddressPrewarmingCountdown _{i} =0$
					\item $\locStoragePrewarmingCountdown _{i} =0$
				\end{enumerate}
		\end{enumerate}

		And some constancies properties:
		\begin{enumerate}
			\item $\locPhaseSize _{i} = \locPhaseSize _{i - 1} - \lc _{i} \cdot \limbsize _{i}$
			\item \If $\isSto _{i} =1$ \Or ($\isAddr _{i} =1$ \et $\isPrefix _{i} =0$) \Then: $\locAccessListTupleSize _{i} = \locAccessListTupleSize _{i - 1} - \lc _{i} \cdot \limbsize _{i}$
			\item $\locAddressPrewarmingCountdown _{i} = \locAddressPrewarmingCountdown _{i - 1} - \isPrefix _{i} \cdot \isAddr _{i}$
			\item \If $\isAddr _{i} =1$ \et $\isSto _{i}=1$ \et $\locAddressPrewarmingCountdown _{i} = \locAddressPrewarmingCountdown _{i + 1}$ \Then:
				\begin{enumerate}
					\item $\locAddressHi _{i} = \locAddressHi _{i + 1}$
					\item $\locAddressLo _{i} = \locAddressLo _{i + 1}$
				\end{enumerate}
			\item $\locStoragePrewarmingCountdown _{i} = \locStoragePrewarmingCountdown _{i} - \done _{i + 2} \cdot \isSto _{i + 2} \cdot (1 - \isPrefix _{i + 2})$
			\item \If ($\isPrefix _{i} =1$ \et $\isAddr _{i} =1$) \Then: $\locTotStorageForThisAddress _{i} = \locTotStorageForThisAddress _{i} - \done _{i + 2} \cdot \isSto _{i + 2} \cdot (1 - \isPrefix _{i + 2})$
		\end{enumerate}
	\end{enumerate}
