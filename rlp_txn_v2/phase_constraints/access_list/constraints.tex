\begin{center}
	\boxed{\text{Throughout this section it is assumed that $\phaseAccessList _{i} = 1$.}}
\end{center}
An access list tuple always starts with the \rlp{} prefix of the tuple, followed by the \rlp{} of an address:
\begin{enumerate}[resume]
	\item \If $\isPrefix_{i} = 1$ \et $\isAddr_{i} = 1$ \et $\isSto_{i} = 0$ Then:
		\begin{enumerate}
			\item $\exoDataColumn{1}_{i} = \locAccessListTupleSize_{i}$
			\item $\exoDataColumn{3}_{i} = 1$
			\item
				\[
					\rlpBytestringPrefix_{i}
					\left(
					\begin{array}{r}
						\exoDataColumn{1},
						\exoDataColumn{2},
						\exoDataColumn{3},
						\ct,
						\maxCt; \\
						\rlpUtilsFlag,
						\INST,
						\exoDataColumn{4},
						\exoDataColumn{5},
						\exoDataColumn{8}; \\
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
			\item $\isPrefix _{i + 1} = 0$
			\item $\isAddr   _{i + 1} = 1$
			\item $\isSto    _{i + 1} = 0$
			\item
				\[
					\rlpAddress_{i+1}
					\left(
					\begin{array}{r}
						\locAddressHi,
						\locAddressLo,
						\ct,
						\maxCt; \\
						\trmFlag,
						\limb,
						\lc,
						\limbsize; \\
					\end{array}
					\right)
				\]
		\end{enumerate}

		After the \rlp{} of an address, we have the \rlp{} of the list of the (possibly empty) list of storage keys:
		\begin{enumerate}[resume]
			\item \If $\isPrefix_{i-1} = 0$ \et $\isAddr_{i-1} = 1$ \et $\isSto_{i-1} = 0$ \et $\done_{i-1} =1$ Then:
				\begin{enumerate}
					\item $\isPrefix _{i} = 1$
					\item $\isAddr   _{i} = 0$
					\item $\isSto    _{i} = 1$
					\item $\exoDataColumn{1}_{i} = 33 \cdot \locTotStorageForThisAddress_{i}$
					\item
						\[
							\rlpBytestringPrefix_{i}
							\left(
							\begin{array}{r}
								\exoDataColumn{1},
								\exoDataColumn{2},
								\exoDataColumn{3},
								\ct,
								\maxCt; \\
								\rlpUtilsFlag,
								\INST,
								\exoDataColumn{4},
								\exoDataColumn{5},
								\exoDataColumn{8}; \\
								\limb,
								\lc,
								\limbsize; \\
							\end{array}
							\right)
						\]

					\item \If $\exoDataColumn{6}_{i} = 1$ \Then:
						\begin{enumerate}
							\item $\isPrefix _{i+1} = 0$
							\item $\isAddr   _{i+1} = 0$
							\item $\isSto    _{i+1} = 1$
						\end{enumerate}

					\item \If $\exoDataColumn{6}_{i} = 0$ \et $\locAddressPrewarmingCountdown_{i} \neq 0$ \Then:
						\begin{enumerate}
							\item $\isPrefix _{i+1} = 1$
							\item $\isAddr   _{i+1} = 1$
							\item $\isSto    _{i+1} = 0$
						\end{enumerate}

					\item \If $\exoDataColumn{6}_{i} = 0$ \et $\locAddressPrewarmingCountdown_{i} = 0$ \Then:
						\begin{enumerate}
							\item $\phaseEnd _{i} = 1$
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}

		Here we constraint what happens when we have to do the \rlp{} of a storage key:
		\begin{enumerate}[resume]
			\item \If $\isPrefix_{i-1} = 0$ \et $\isAddr_{i-1} = 0$ \et $\isSto_{i-1} = 1$ \et $\done_{i-1} =1$ Then:
				\begin{enumerate}
					\item $\exoDataColumn{1}_{i} = \exoDataColumn{1}_{i+1} = \exoDataColumn{1}_{i+2}$
					\item $\exoDataColumn{2}_{i} = \exoDataColumn{2}_{i+1} = \exoDataColumn{2}_{i+2}$
					\item \[
							\rlpStorageKey_{i}
							\left(
							\begin{array}{r}
								\exoDataColumn{1},
								\exoDataColumn{2},
								\ct,
								\maxCt; \\
								\rlpUtilsFlag,
								\INST; \\
								\limb,
								\lc,
								\limbsize; \\
							\end{array}
							\right)
						\]
				\end{enumerate}
		\end{enumerate}
		And the possibilities after the \rlp{} of a storage key:
		\begin{enumerate}[resume]
			\item \If $\isPrefix_{i} = 0$ \et $\isAddr_{i} = 0$ \et $\isSto_{i} = 1$ \et $\done_{i} =1$ \Then:
				\begin{enumerate}
					\item \If $\locTotStorageForThisAddress_{i} \neq 0$ \Then: $\isPrefix_{i+1} = 0$ \et $\isAddr_{i+1} = 0$ \et $\isSto_{i+1} = 1$
					\item \If $\locTotStorageForThisAddress_{i} = 0$ \Then:
						\begin{enumerate}
							\item $\locAccessListTupleSize_{i} = 0$
							\item \If $\locAddressPrewarmingCountdown_{i} \neq 0$ \Then: $\isPrefix_{i+1} = 1$ \et $\isAddr_{i+1} = 1$ \et $\isSto_{i+1} = 0$
							\item \If $\locAddressPrewarmingCountdown_{i} = 0$ \Then: $\phaseEnd_{i} =1$
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}

		We constraint finalize the phase before the end by imposing:
		\begin{enumerate}
			\item \If $\phaseEnd_{i} =1$ \Then:
				\begin{enumerate}
					\item $\locPhaseSize_{i} =0$
					\item $\locAddressPrewarmingCountdown_{i} =0$
					\item $\locStoragePrewarmingCountdown_{i} =0$
				\end{enumerate}
		\end{enumerate}

		And some constancies properties:
		\begin{enumerate}
			\item $\locPhaseSize_{i} = \locPhaseSize_{i-1} - \lc_{i} \cdot \limbsize_{i}$
			\item \If $\isSto_{i} =1$ \Or ($\isAddr_{i} =1$ \et $\isPrefix_{i} =0$) \Then: $\locAccessListTupleSize_{i} = \locAccessListTupleSize_{i-1} - \lc_{i} \cdot \limbsize_{i}$
			\item $\locAddressPrewarmingCountdown_{i} = \locAddressPrewarmingCountdown_{i-1} - \isPrefix_{i} \cdot \isAddr_{i}$
			\item \If $\isAddr_{i} =1$ \et $\isSto_{i}=1$ \et $\locAddressPrewarmingCountdown_{i} = \locAddressPrewarmingCountdown_{i+1}$ \Then:
				\begin{enumerate}
					\item $\locAddressHi_{i} = \locAddressHi_{i+1}$
					\item $\locAddressLo_{i} = \locAddressLo_{i+1}$
				\end{enumerate}
			\item $\locStoragePrewarmingCountdown_{i} = \locStoragePrewarmingCountdown_{i} - \done_{i+2} \cdot \isSto_{i+2} \cdot (1 - \isPrefix_{i+2})$
			\item \If ($\isPrefix_{i} =1$ \et $\isAddr_{i} =1$) \Then: $\locTotStorageForThisAddress_{i} = \locTotStorageForThisAddress_{i} - \done_{i+2} \cdot \isSto_{i+2} \cdot (1 - \isPrefix_{i+2})$
		\end{enumerate}
	\end{enumerate}
