We impose some generalities:
\begin{enumerate}
	\item we impose
		$\limbBelongsToBothLtAndLx {
			anchorRow = i ,
			relOffset = 0 ,
		}$
\end{enumerate}
We first determine the \rlp{} prefix of the data on the first row:
\begin{enumerate}[resume]
	\item \If $\locIsPayloadSizeAnalysisRow _{i} = 1$ \Then
		\begin{enumerate}
			\item $\rlpTxnSharedColumnIsPrefix _{i} = 1$
			\item we initialize the countdowns
				\[
					\left\{ \begin{array}{lcl}
						\locZeroBytesCountdown    _{i} & = & \rlpTxnTransactionColumnNumberOfZero    _{i - 1} \\
						\locNonzeroBytesCountdown _{i} & = & \rlpTxnTransactionColumnNumberOfNonZero _{i - 1} \\
					\end{array} \right.
				\]
			\item we introduce some shorthands
				\[
					\left\{ \begin{array}{lcl}
						\locTransactionPayloadSize & \define &
						\left[ \begin{array}{cl}
							+ & \rlpTxnTransactionColumnNumberOfZero    _{i - 1} \\
							+ & \rlpTxnTransactionColumnNumberOfNonZero _{i - 1} \\
						\end{array} \right]
						\vspace{2mm}
						\\
						\locPayloadIsNonempty          & \define & \rlpTxnComputationColumnExoDataColumn{4} _{i}      \\
						\locPayloadIsEmpty             & \define & 1 - \locPayloadIsNonempty   \\
						\locMaybeFirstByteOfByteString & \define & \rlpTxnComputationColumnExoDataColumn{8} _{i  + 1} \\
						\locFirstByteOrZero            & \define &
						\left[ \begin{array}{cl}
							\cdot & \locPayloadIsNonempty          \\
							\cdot & \locMaybeFirstByteOfByteString \\
						\end{array} \right]
					\end{array} \right.
				\]
				\saNote{}
				The above mixes in an \textbf{output} of the upcoming \rlpUtilsMod{} module instruction
				with one of the same instruction's \textbf{inputs}.
				Indeed \locPayloadIsNonempty{} is an output of said (upcoming) instruction.
				Inspection of the relevant \rlpUtilsMod{} instruction
				reveals that this output is a bit and is logically equivalent to
				$[\, \locTransactionPayloadSize \neq 0 \,]$,
				see section~(\ref{rlp utils: instructions: byte string processing}).
				Inspection of the next row also reveals that, when $\locPayloadIsNonempty \equiv \true$,
				the value contained in $\locMaybeFirstByteOfByteString$
				will be the first byte of the payload byte string.
			\item we impose
				\[
					\rlpProcessByteString {
						anchorRow        = i                          ,
						relOffset        = 0                          ,
						byteStringLength = \locTransactionPayloadSize ,
						firstByte        = \locFirstByteOrZero        ,
						isList           = \false                     ,
						mustBeNontrivial = \false                     ,
					}
				\]
			\item \If $\locPayloadIsEmpty = \true$ \Then
				\[
					\left\{ \begin{array}{lcl}
						\locZeroBytesCountdown    _{i} & = & 0 \\
						\locNonzeroBytesCountdown _{i} & = & 0 \\
					\end{array} \right.
				\]
			\item $\phaseEnd _{i} = 1 - \locPayloadIsNonempty$
		\end{enumerate}
\end{enumerate}
We now deal with the \rlp{}-ization of the actual data,
as contained in the $\rlpTxnComputationColumnLimb$ column.
We delegate to \rlpUtilsMod{} proving that the limb is up to $\llarge$ bytes long, and counting the number of zeros and nonzeros byte.
\begin{enumerate}[resume]
	\item \If $\locIsLimbContentAnalysisRow _{i} = 1$ \Then
		\begin{enumerate}
			\item $\rlpTxnSharedColumnIsPrefix     _{i} = 0$
			\item we call the \rlpUtilsMod{} module
				\[
					\rlpUtilsInstCallDataPricing {
						anchorRow = i              ,
						relOffset = 0              ,
						limb      = \rlpTxnComputationColumnLimb     _{i} ,
						nBytes    = \rlpTxnComputationColumnLimbSize _{i} ,
					}
				\]
			\item we update the countdowns
				\[
					\left\{ \begin{array}{lcl}
						\locZeroBytesCountdown    _{i} & = & \locZeroBytesCountdown    _{i - 1} - \locZeroBytesInLimb    _{i} \\
						\locNonzeroBytesCountdown _{i} & = & \locNonzeroBytesCountdown _{i - 1} - \locNonzeroBytesInLimb _{i} \\
					\end{array} \right.
				\]
			\item $\phaseEnd _{i} = \done _{i}$
			\item \If $\phaseEnd _{i} = 0$ \Then $\rlpTxnComputationColumnLimbSize _{i} = \llarge$
		\end{enumerate}
	\item we impose finalization constraint:
		\begin{enumerate}[resume]
			\item \If $\locZeroBytesCountdown _{i} = 0$ \et $\locNonzeroBytesCountdown _{i} = 0$ \Then $\phaseEnd _{i} = 1$
			\item \If $\phaseEnd _{i} = 1$ \Then $\locZeroBytesCountdown _{i} = 0$ \et   $\locNonzeroBytesCountdown _{i} = 0$
		\end{enumerate}
\end{enumerate}

