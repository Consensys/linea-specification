\begin{center}
	\boxed{\text{In all this section, it is assumed that}
	\left\{ \begin{array}{lcl}
		\phaseData                   _{i} & = & 1 \\
		\locIsLimbContentAnalysisRow _{i} & = & 1 \\
	\end{array} \right.
	}
\end{center}
We now deal with the \rlp{}-ization of the actual payload.
We delegate to the \rlpUtilsMod{} module the verification that
the \rlpTxnComputationColumnLimb{} contents are $1 \leq \rlpTxnComputationColumnLimbSize \leq \llarge$ bytes long and
left aligned on the $\llarge$-th byte,
as well as performing the actual counting of zero and nonzero bytes
which make up the \rlpTxnComputationColumnLimbSize{} relevant bytes of \rlpTxnComputationColumnLimb{}.
\begin{enumerate}
	\item $\rlpTxnComputationColumnIsPrefix     _{i} = 0$
	\item we call the \rlpUtilsMod{} module
		\[
			\rlpUtilsInstCallDataPricing {
				anchorRow = i              ,
				relOffset = 0              ,
				limb      = \rlpTxnComputationColumnLimb     _{i} ,
				nBytes    = \rlpTxnComputationColumnLimbSize _{i} ,
			}
		\]
		and we define the following shorthands:
		\[
			\left\{ \begin{array}{lcl}
				\locZeroBytesInLimb    _{i} & \define & \rlpTxnComputationColumnExoDataColumn{5} _{i} \\
				\locNonzeroBytesInLimb _{i} & \define & \rlpTxnComputationColumnExoDataColumn{7} _{i} \\
			\end{array} \right.
		\]
		\saNote{}
		We remind the reader that,
		according to section~(\ref{rlp utils: instructions: data pricing: constraints}),
		\[
			\left\{ \begin{array}{l}
				0 \leq \locZeroBytesInLimb    _{i} \leq \llarge \\
				0 \leq \locNonzeroBytesInLimb _{i} \leq \llarge \\
				\rlpTxnComputationColumnLimbSize _{i} =
				\left[ \begin{array}{cr}
					+ & \locZeroBytesInLimb    _{i} \\
					+ & \locNonzeroBytesInLimb _{i} \\
				\end{array} \right]
			\end{array} \right.
		\]
	\item we update the countdowns
		\[
			\left\{ \begin{array}{lcl}
				\locZeroBytesCountdown    _{i} & = & \locZeroBytesCountdown    _{i - 1} - \locZeroBytesInLimb    _{i} \\
				\locNonzeroBytesCountdown _{i} & = & \locNonzeroBytesCountdown _{i - 1} - \locNonzeroBytesInLimb _{i} \\
			\end{array} \right.
		\]
	\item we constrain \phaseEnd{} and add further relations:
		\begin{enumerate}[resume]
			\item \If $\phaseEnd _{i} = 0$ \Then $\rlpTxnComputationColumnLimbSize _{i} = \llarge$
			\item \If $\locZeroBytesCountdown _{i} = 0$ \et $\locNonzeroBytesCountdown _{i} = 0$ \Then $\phaseEnd _{i} = 1$
			\item \If $\phaseEnd _{i} = 1$ \Then $\locZeroBytesCountdown _{i} = 0$ \et   $\locNonzeroBytesCountdown _{i} = 0$
			\item $\phaseEnd _{i} = \done _{i}$
		\end{enumerate}
\end{enumerate}
\saNote{}
The above constraining of \phaseEnd{},
along with section~(\ref{rlp txn v2: generalities: ct and ct_max}),
implicitly constrain $\maxCt$ to be
\[
	\left\lceil \frac{\left\| \textbf{p} \right\|}{\llarge} \right\rceil
\]
where we recall that \textbf{p} is the payload of the transaction.
