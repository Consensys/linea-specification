We define the following ``compound constraint'' for the \rlp{}-ization process of \texttt{INTEGER}'s
\[
	\rlpProcessInteger {
		anchorRow = i                 ,
		relOffset = \relof            ,
		integerHi = \loc{integer\_hi} ,
		integerLo = \loc{integer\_lo} ,
	}
\]
which stands for the following set of constraints
\begin{description}
	\item[\underline{\underline{\rlpUtilsMod{} instruction call:}}]
		we impose
		\[
			\rlpUtilsInstCallInteger {
				anchorRow = i                 ,
				relOffset = \relof            ,
				integerHi = \loc{integer\_hi} ,
				integerLo = \loc{integer\_lo} ,
			}
		\]
	\item[\underline{\underline{Deriving shorthands:}}]
		we define the following shorthands
		\[
			\left\{ \begin{array}{lcl}
				\locOutputHasRlpPrefix     & \define & \outputColumn {1} _{i + \relof} \\
				\locOutputRlpPrefix        & \define & \outputColumn {2} _{i + \relof} \\
				\locOutputHasNonzeroHiPart & \define & \outputColumn {3} _{i + \relof} \\
				\locOutputLeftShiftedInput & \define & \outputColumn {4} _{i + \relof} \\
				\locOutputNBytes           & \define & \outputColumn {5} _{i + \relof} \\
			\end{array} \right.
		\]
		and furthermore we set
		\begin{enumerate}
			\item \If $\locOutputHasNonzeroHiPart = 0$ \Then
				\[
					\left\{ \begin{array}{lcl}
						\locLastLimb   & \define & \locOutputLeftShiftedInput \\
						\locLastNBytes & \define & \locOutputNBytes           \\
					\end{array} \right.
				\]
			\item \If $\locOutputHasNonzeroHiPart = 1$ \Then
				\[
					\left\{ \begin{array}{lcl}
						\locLastLimb   & \define & \loc{integer\_lo} \\
						\locLastNBytes & \define & \llarge           \\
					\end{array} \right.
				\]
		\end{enumerate}
	\item[\underline{\underline{Setting \maxCt:}}]
		we impose $\maxCt _{i + \relof} = \rlpIntegerInstNbRows - 1$
	\item[\underline{\underline{Enshrining the \rlp{} prefix into the \rlp{} string:}}]
		we impose
		\[
			\conditionallySetLimb {
				anchorRow  = i                       ,
				relOffset  = \relof                  ,
				condition  = \locOutputHasRlpPrefix  ,
				limb       = \locOutputRlpPrefix     ,
				nBytes     = 1                       ,
			} \vspace{2mm} \\
		\]
		\saNote{}
		Integers $\loc{integer}$ in \ethereum{} are in $\mathbb{N}_{256}$.
		When represented as tuples of bytes $\in\mathbb{O}^*$,
		they fit into tuples of length $0$ to $\evmWordSize$.
		Their \rlp{}-prefix is therefore at most $1$ byte long.
		To be precise: an $\loc{integer}$ produces a prefix when \rlp{}-ized if and only if
		it is in the range $\texttt{0x\,00} < \loc{integer} < \texttt{0x\,7f}$
	\item[\underline{\underline{Enshrining the hi part of the (large) integer into the \rlp{} string:}}]
		we impose
		\[
			\conditionallySetLimb {
				anchorRow  = i                          ,
				relOffset  = \relof + 1                 ,
				condition  = \locOutputHasNonzeroHiPart ,
				limb       = \locOutputLeftShiftedInput ,
				nBytes     = \locOutputNBytes           ,
			}
		\]
	\item[\underline{\underline{Enshrining the lo part of the integer into the \rlp{} string:}}]
		we impose
		\[
			\setLimb{
				anchorRow  = i              ,
				relOffset  = \relof + 2     ,
				limb       = \locLastLimb   ,
				nBytes     = \locLastNBytes ,
			}
		\]
\end{description}
