We define the following shorthands
\[
	\rlpProcessByteString {
		anchorRow        = i                     ,
		relOffset        = \relof                ,
		byteStringLength = \loc{length}          ,
		firstByte        = \loc{first\_byte}     ,
		isList           = \loc{is\_list}        ,
		mustBeNontrivial = \loc{true\_or\_false} ,
	}
\]
which stands for the following collection of constraints:
\begin{description}
	\item[\underline{\underline{\rlpUtilsMod{} instruction call:}}] 
		we impose
		\[
			\rlpUtilsInstCallByteString {
				anchorRow        = i                 ,
				relOffset        = \relof            ,
				byteStringLength = \loc{length}      ,
				firstByte        = \loc{first\_byte} ,
				isList           = \loc{is\_list}    ,
			}
		\]
		and we define the following shorthands
		\[
			\left\{ \begin{array}{lcl}
				\locRlpPrefixRequired    & \define & \exoDataColumn{4} _{i + \relof} \\
				\locRlpPrefix            & \define & \exoDataColumn{5} _{i + \relof} \\
				\locByteStringIsNonempty & \define & \exoDataColumn{6} _{i + \relof} \\
				\locRlpPrefixByteSize    & \define & \exoDataColumn{8} _{i + \relof} \\
			\end{array} \right.
		\]
	\item[\underline{\underline{Enshrining the byte string's \rlp{} prefix into the \rlp{} string:}}] 
		we impose
		\[
			\conditionallySetLimb {
				anchorRow = i                     ,
				relOffset = \relof                ,
				condition = \locRlpPrefixRequired ,
				limb      = \locRlpPrefix         ,
				nBytes    = \locRlpPrefixByteSize ,
			}
		\]
	\item[\underline{\underline{Imposing nontriviality:}}] 
		\If $\loc{true\_or\_false} = \true$ \Then we impose
		\[
			\left\{ \begin{array}{lcl}
				\locRlpPrefixRequired    & = & \true \\
				\locByteStringIsNonempty & = & \true \\
			\end{array} \right.
		\]
\end{description}
