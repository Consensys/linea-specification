It may make sense to impose that the ROM module reject byte code starting with 0xEF

Pros:
- this would ensure that no delegated account gets treated as an account with code

Cons:
- this will interfere with "data contracts" in particular when it comes to EXTCODECOPY-ing from them

We have a bit of an issue. Indeed in https://github.com/ethereum/execution-specs/blob/2b1d1c0d1218128244d44064e0927d377adead81/src/ethereum/forks/bpo5/vm/eoa_delegation.py#L30C1-L52C1 we find:

```python
def is_valid_delegation(code: bytes) -> bool:
    """
    Whether the code is a valid delegation designation.

    Parameters
    ----------
    code: `bytes`
        The code to check.

    Returns
    -------
    valid : `bool`
        True if the code is a valid delegation designation,
        False otherwise.

    """
    if (
        len(code) == EOA_DELEGATED_CODE_LENGTH
        and code[:EOA_DELEGATION_MARKER_LENGTH] == EOA_DELEGATION_MARKER
    ):
        return True
    return False
```

So that we have accounts that _are_ delegated inspite of never having been delegated via a type 4 transaction.
I.e. we have _de facto_ delegated accounts. Note that _de facto_ delegation may be observed in the ROM module.
We can add a CFI-constant column that is specified as follows
```rust
CODE_IS_DELEGATION_CODE ≡ CFI-constant
If [first row of CFI] Then CODE_IS_DELEGATION_CODE ≡   rom.CODE_SIZE == 23
                                                     ∧ rom.LIMB_BYTE[i + 0] == 0xef
                                                     ∧ rom.LIMB_BYTE[i + 1] == 0x01
                                                   ≡   rom.CODE_SIZE == 23
                                                     ∧ rom.LIMB_BYTE[i + 0] << 16 + rom.LIMB_BYTE[i + 1] << 8 + rom.LIMB_BYTE[i + 2] == 0xef0100
```
We then include a `CODE_IS_DELEGATION_CODE` column in the `ROM_LEX` module.
We must then enhance the lookup from `HUB → ROM_LEX` by including

**Question:** how do we handle the fact that an account may change byte code this way ?
The issue being that we currently identify CFI with a tuple [ address, deployment_number, deployment_status ]
There is no reason for these to change ... I.e. we don't want to raise the deployment number.
We may, however, add a delegation_number ...

- the ROM module is 100% capable of detecting delegations
- the ROM_LEX module should `know` about delegations, too, as well as the delegation address
    - since we do a byte decomposition of the byte code we should add a DELEGATION_ADDRESS column to the ROM
    - we fill it using the bytes from the code
    - we do it in the most straight forward way i.e. without an accumulator
- we may want to trigger `ROM_LEX` and `ROM` with every delegation
- we may want to enhance the CFI identifier to [ address, deployment_number, deployment_status, delegation_number ]
- we may want to add a column like so

```rust
hub.acc/ACCOUNT_NOT_CURRENTLY_UNDER_DEPLOYMENT_AND_HAS_CODE_SIZE_23

    ≡ [acc/CODE_SIZE == 23] ∧ ¬acc/DEPLOYMENT_STATUS
```

We should have that
```rust
hub.acc/ACCOUNT_NOT_CURRENTLY_UNDER_DEPLOYMENT_AND_HAS_CODE_SIZE_23 ≡ true
    =>
        hub.acc/TRIGGER_ROM_LEX ≡ true
```

- the `hub.acc/` perspective thus requires now a `DELEGATION_NUMBER` and `DELEGATION_NUMBER_NEW` column pair.

One should keep in mind that deployments can lead to the creation of pre-delegated accounts.
The `DELEGATION_NUMBER` should be relative to a `DEPLOYMENT_NUMBER` I would suggest.
We can no longer impose that delegation data is mutable only during `TX_AUTH` as delegation data may see updates when doing a `RETURN` in a deployment
We must impose that a special lookup is triggered from

```rust
hub.acc/XXX -> romlex.XXX
```

whenever
- TX_AUTH and we do it for the current values
- in all other cases using the updated value
    - this will take care of (I hope so, anyways) of all cases where you deploy byte code of the form `0xef0100 <20 bytes>`

