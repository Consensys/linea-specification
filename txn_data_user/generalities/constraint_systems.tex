We impose that
\begin{enumerate}
	\item \txnDataCmptnWcpFlag{} is binary (\sanityCheck)
	\item \txnDataCmptnEucFlag{} is binary (\sanityCheck)
	\item
		$\txnDataCmptnWcpFlag \cdot \txnDataCmptnEucFlag \equiv 0$ (\sanityCheck)
		i.e. \txnDataCmptnWcpFlag{} and \txnDataCmptnEucFlag{} are \textbf{exclusive binary flags}
\end{enumerate}
We define parametrized constraint families to deal with setting comparisons
\[
	\left\{ \begin{array}{lcl}
		\smallCallToLt {
			anchorRow = i            ,
			relOffset = \relof       ,
			argOneLo  = \col{arg\_1} ,
			argTwoLo  = \col{arg\_2} ,
		}
		& \iff &
		\left\{ \begin{array}{lcl}
			\txnDataCmptnWcpFlag   _{i + \relof}  & = & \true        \\
			\txnDataCmptnEucFlag   _{i + \relof}  & = & \nothing     \\
			\txnDataCmptnArgOneLo  _{i + \relof}  & = & \col{arg\_1} \\
			\txnDataCmptnArgTwoLo  _{i + \relof}  & = & \col{arg\_2} \\
			\txnDataCmptnInst      _{i + \relof}  & = & \inst{LT}    \\
		\end{array} \right. \vspace{2mm} \\
		\smallCallToLeq {
			anchorRow = i            ,
			relOffset = \relof       ,
			argOneLo  = \col{arg\_1} ,
			argTwoLo  = \col{arg\_2} ,
		}
		& \iff &
		\left\{ \begin{array}{lcl}
			\txnDataCmptnWcpFlag   _{i + \relof}  & = & \true        \\
			\txnDataCmptnEucFlag   _{i + \relof}  & = & \nothing     \\
			\txnDataCmptnArgOneLo  _{i + \relof}  & = & \col{arg\_1} \\
			\txnDataCmptnArgTwoLo  _{i + \relof}  & = & \col{arg\_2} \\
			\txnDataCmptnInst      _{i + \relof}  & = & \inst{LEQ}    \\
		\end{array} \right. \vspace{2mm} \\
		\smallCallToIszero {
			anchorRow = i            ,
			relOffset = \relof       ,
			argOneLo  = \col{arg\_1} ,
		}
		& \iff &
		\left\{ \begin{array}{lcl}
			\txnDataCmptnWcpFlag   _{i + \relof} & = & \true         \\
			\txnDataCmptnEucFlag   _{i + \relof} & = & \nothing     \\
			\txnDataCmptnArgOneLo  _{i + \relof} & = & \col{arg\_1}  \\
			\txnDataCmptnArgTwoLo  _{i + \relof} & = & \nothing      \\
			\txnDataCmptnInst      _{i + \relof} & = & \inst{ISZERO} \\
		\end{array} \right. \vspace{2mm} \\
		\callToEuc
		{i}{\relof}
		{\col{arg\_1}}
		{\col{arg\_2}}
		& \iff &
		\left\{ \begin{array}{lcl}
			\txnDataCmptnWcpFlag   _{i + \relof} & = & \nothing      \\
			\txnDataCmptnEucFlag   _{i + \relof} & = & \true         \\
			\txnDataCmptnArgOneLo  _{i + \relof} & = & \col{arg\_1}  \\
			\txnDataCmptnArgTwoLo  _{i + \relof} & = & \col{arg\_2}  \\
		\end{array} \right. \vspace{4mm} \\
		\resultMustBeFalse {
			anchorRow = i      ,
			relOffset = \relof ,
		}
		& \iff &
		\txnDataCmptnRes _{i + \relof} = \false \\
		\resultMustBeTrue {
			anchorRow = i      ,
			relOffset = \relof ,
		}
		& \iff &
		\txnDataCmptnRes _{i + \relof} = \true  \\
	\end{array} \right.
\]
\saNote{}
All comparisons requested in the present module involve ``small values''
i.e. values that fit into a single $\oneTwoEight$-byte integer.
These values arise from either the \rlpTxnMod{},
which already enforces various smallness conditions,
or from \linea{}'s state (e.g. \txnDataHubInitialBalance{}).
Compare with the lookup from
section~(\ref{user txn data: lookups: wcp})
which sets the ``high'' parts of the \wcpMod{} counterparts to zero.
