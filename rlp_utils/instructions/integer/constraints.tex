\[
    \boxed{\text{All constraints in this subsection assume } \isRlpUtilsMacro_{i} = 1 \et \rlpUtilsInstIntegerFlag _{i} = 1 }
\]
We use the following shorthands:
\[
    \left\{ \begin{array}{lcl}
        \locInputIntegerHi & \define & \inputColumn {1} _{i} \\
        \locInputIntegerLo & \define & \inputColumn {2} _{i} \\
    \end{array} \right.
    \quad\text{and}\quad
    \left\{ \begin{array}{lcl}
        \locOutHasRlpPrefix     & \define & \resultColumn {1} _{i} \\
        \locOutRlpPrefix        & \define & \resultColumn {2} _{i} \\
        \locOutHasNonzeroHiPart & \define & \resultColumn {3} _{i} \\
        \locOutLeftShiftedInput & \define & \resultColumn {4} _{i} \\
        \locOutNBytes           & \define & \resultColumn {5} _{i} \\
    \end{array} \right.
\]
\begin{description}
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetIntegerZero)$:}} \underline{Detecting integer is zero:}]
        we impose that
        \[
            \wcpCallToIszero {
                anchorRow = i                     ,
                relOffset = \rowOffsetIntegerZero ,
                argOneHi  = \locInputIntegerHi            ,
                argOneLo  = \locInputIntegerLo            ,
            }
        \]
        and we derive the following shorthand
        \[
            \locIntIsZero \define \res_{i + \rowOffsetIntegerZero}
        \]
    \item[\underline{\underline{The ``zero'' case:}}]
        \If $\locIntIsZero = 1$ \Then:
        \[
            \left\{ \begin{array}{lcl}
                \maxCt       _{i + 1}   & = & 0                 \\
                \locOutHasRlpPrefix     & = & \gZero            \\
                \locOutRlpPrefix        & = & 0                 \\
                \locOutHasNonzeroHiPart & = & 0                 \\
                \locOutLeftShiftedInput & = & \rlprefixShortInt \\
                \locOutNBytes           & = & 1                 \\
            \end{array} \right.
        \]
        \saNote{}
        This finishes the computation phase for this particular subcase.
    \item[\underline{\underline{The ``nonzero'' case:}}]
        \If $\locIntIsZero = 0$ \Then we impose that
        \begin{description}
            \item[\underline{Setting \maxCt:}]
                we impose $\maxCt_{i + 1} = \integerCtMax$.
            \item[\underline{Processing row $n^\circ(\rowOffsetHighZero)$:} \underline{Detecting null high part:}]
                we impose that
                \[
                    \wcpCallToGt {
                        anchorRow = i                  ,
                        relOffset = \rowOffsetHighZero ,
                        argOneHi  = 0                  ,
                        argOneLo  = \locInputIntegerHi      ,
                        argTwoLo  = 0                  ,
                    }
                \]
                and we derive the following shorthand
                \[
                    \left\{ \begin{array}{lcl}
                        \locBigInt       & \define &     \res      _{i + \rowOffsetHighZero} \\
                        \locNBytesHiPart & \define & 1 + \wcpCtMax _{i + \rowOffsetHighZero} \\
                    \end{array} \right.
                \]
            \item[\underline{Processing row $n^\circ(\rowOffsetSmallInt)$:} \underline{Detecting small integer:}]
                we impose that
                \[
                    \wcpCallToLeq {
                        anchorRow = i                  ,
                        relOffset = \rowOffsetSmallInt ,
                        argOneHi  = 0                  ,
                        argOneLo  = \locInputIntegerLo      ,
                        argTwoLo  = \oneTwoEight       ,
                    }
                \]
                and we derive the following shorthand
                \[
                    \left\{ \begin{array}{lcl}
                        \locSmallInt     & \define & (1 - \locBigInt) \cdot \res_{i + \rowOffsetSmallInt} \\
                        \locNBytesLoPart & \define & 1 + \wcpCtMax _{i + \rowOffsetSmallInt}              \\
                        \locTotalSize & \define &
                        \left[ \begin{array}{crcl}
                            + & \locBigInt       & \cdot & (\llarge + \locNBytesHiPart) \\
                            + & (1 - \locBigInt) & \cdot & \locNBytesLoPart             \\
                        \end{array} \right] \vspace{2mm} \\
                        \locNBytes    & \define &
                        \left[ \begin{array}{crcl}
                            + & \locBigInt       & \cdot & \locNBytesHiPart  \\
                            + & (1 - \locBigInt) & \cdot & \locNBytesLoPart  \\
                        \end{array} \right]
                    \end{array} \right.
                \]
            \item[\underline{Finalization:}]
                we impose
                \[
                    \left\{ \begin{array}{lcl}
                        \shfFlag          _{i + \rowOffsetSmallInt} & = & 1                                 \\
                        \shfArg           _{i + \rowOffsetSmallInt} & = & \llarge - \locNBytes              \\
                        \locOutHasRlpPrefix                         & = & 1 - \locSmallInt                  \\
                        \locOutRlpPrefix                            & = & \rlprefixShortInt + \locTotalSize \\
                        \locOutHasNonzeroHiPart                     & = & \locBigInt                        \\
                        \locOutLeftShiftedInput                     & = & \locPaddedLimb                    \\
                        \locOutNBytes                               & = & \locNBytes                        \\
                    \end{array} \right.
                \]
                where we used the following shorthand
                \[
                        \locPaddedLimb \define \shfPower _{i + \rowOffsetSmallInt} \cdot
                        \left[ \begin{array}{clcl}
                            + & \locBigInt       & \cdot & \locInputIntegerHi \\
                            + & (1 - \locBigInt) & \cdot & \locInputIntegerLo \\
                        \end{array} \right]
                \]
        \end{description}
\end{description}
