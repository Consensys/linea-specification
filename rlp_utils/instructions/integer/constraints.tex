\[
    \boxed{\text{All constraints in this subsection assume } \isRlpUtilsMacro_{i} = 1 \et \rlpUtilsInstIntegerFlag _{i} = 1 }
\]
We use the following shorthands:
\[
    \left\{ \begin{array}{lcl}
        \locInputIntegerHi & \define & \rlpUtilsDataColumn{1} _{i} \\
        \locInputIntegerLo & \define & \rlpUtilsDataColumn{2} _{i} \\
    \end{array} \right.
    \quad\text{and}\quad
    \left\{ \begin{array}{lclr}
        \locOutputInputIntegerIsNonzero        & \define & \rlpUtilsDataColumn{3} _{i} & \prediction \\
        \locOutputInputIngegerHasNonzeroHiPart & \define & \rlpUtilsDataColumn{4} _{i} & \prediction \\
        \locOutputRlpPrefixRequired            & \define & \rlpUtilsDataColumn{5} _{i} & \prediction \\
        \locOutputRlpPrefix                    & \define & \rlpUtilsDataColumn{6} _{i} & \prediction \\
        \locOutputLeadingLimbLeftShifted       & \define & \rlpUtilsDataColumn{7} _{i} & \prediction \\
        \locOutputLeadingLimbByteSize          & \define & \rlpUtilsDataColumn{8} _{i} & \prediction \\
    \end{array} \right.
\]
The purpose of the constraints below is to justify the predictions i.e. the cells labeled with $\prediction$ above.
\begin{description}
        \input{instructions/integer/rows/setting_ct_max}
        \input{instructions/integer/rows/detecting_integer_is_zero}
        \input{instructions/integer/rows/detecting_integer_hi_is_zero}
        \input{instructions/integer/rows/detecting_integer_lt_128}
        \input{instructions/integer/rows/get_shifting_factor}
        \input{instructions/integer/rows/justifying_predictions}
\end{description}
