\[
    \boxed{\text{All constraints in this subsection assume } \isRlpUtilsMacro_{i} = 1 \et \INST_{i} = \inst{BYTESTRING}}
\]
We use the following shorthand:
\[
    \left\{ \begin{array}{lcl}
        \locIsList             & \define & \inputColumn{1}_{i}                                                            \\
        \locBytestringLength   & \define & \inputColumn{2}_{i}                                                            \\
        \locFirstByte          & \define & \inputColumn{3}_{i}                                                            \\
        \locBaseRlpPrefixShort & \define & \rlprefixShortInt \cdot (1 - \locIsList) + \rlprefixShortList \cdot \locIsList \\
        \locBaseRlpPrefixLong  & \define & \rlprefixLongInt  \cdot (1 - \locIsList) + \rlprefixLongList  \cdot \locIsList \\
    \end{array} \right.
\]
We impose the following constraints
\begin{description}
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetNullString)$:}} \underline{Detecting the empty byte string:}]
        we impose that
        \[
            \wcpCallToIszero {
                anchorRow = i                    ,
                relOffset = \rowOffsetNullString ,
                argOneLo  = \locBytestringLength ,
            }
        \]
        and we derive the following shorthand
        \[
            \locNullBytestring \define \res_{i + \rowOffsetNullString}
        \]
    \item[\underline{\underline{Setting \maxCt:}}]
        we impose that
        \begin{enumerate}
            \item \If $\locNullBytestring = 1$ \Then $\maxCt _{i + 1} = \bytestringEmptyCtMax$
            \item \If $\locNullBytestring = 0$ \Then $\maxCt _{i + 1} = \bytestringNonEmptyCtMax$
        \end{enumerate}
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetNullString)$:}} \underline{The empty byte string case:}]
        \If $\locNullBytestring = 1$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 1                                             \\
                \resultColumn{2} _{i} & = & \locBaseRlpPrefixShort \cdot 256 ^{\llargeMO} \\
                \resultColumn{3} _{i} & = & 0                                             \\
                \resultColumn{5} _{i} & = & 1                                             \\
            \end{array} \right.
        \]
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetLengthIsOne)$:}} \underline{The nonempty byte string case:}]
        \If $\locNullBytestring = 0$ we impose
        \[
            \wcpCallToEq {
                anchorRow = i                     ,
                relOffset = \rowOffsetLengthIsOne ,
                argOneLo  = \locBytestringLength  ,
                argTwoLo  = 1                     ,
            }
        \]
        and we derive the following shorthand
        \[
            \locLengthIsOne \define \res_{i + \rowOffsetLengthIsOne}
        \]
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetCompareOneTwoEight)$:}} \underline{Comparing data to $\rlprefixShortInt$:}]
        we impose that
        \[
            \wcpCallToLeq {
                anchorRow = i                            ,
                relOffset = \rowOffsetCompareOneTwoEight ,
                argOneLo  = \locFirstByte                ,
                argTwoLo  = \rlprefixShortInt            ,
            }
        \]
        and we derive the following shorthand
        \[
            \locByteIsLeqOneTwoEight \define \res_{i + \rowOffsetCompareOneTwoEight}
        \]
        \If $\locByteIsLeqOneTwoEight = 1$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 0                \\
                \resultColumn{2} _{i} & = & 0 \quad (\trash) \\
                \resultColumn{5} _{i} & = & 0 \quad (\trash) \\
            \end{array} \right.
        \]
        \If $\locByteIsLeqOneTwoEight = 0$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 1                                                   \\
                \resultColumn{2} _{i} & = & (\locBaseRlpPrefixShort + 1) \cdot 256 ^{\llargeMO} \\
                \resultColumn{3} _{i} & = & 1                                                   \\
            \end{array} \right.
        \]
        \If $\locLengthIsOne = 0$:
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetCompareFiftyFive)$:}} \underline{Comparing data length to $\fiftySix$:}]
        we impose that
        \[
            \wcpCallToLt {
                anchorRow = i                          ,
                relOffset = \rowOffsetCompareFiftyFive ,
                argOneLo  = \locBytestringLength       ,
                argTwoLo  = \fiftySix                  ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthLtFiftySix  & \define & \res_{i + \rowOffsetCompareFiftyFive} \\
            \end{array} \right.
        \]
        \If $\locLengthLtFiftySix = 1$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 1                                                                          \\
                \resultColumn{2} _{i} & = & (\locBaseRlpPrefixShort + \locBytestringLength_{i}) \cdot 256 ^{\llargeMO} \\
                \resultColumn{5} _{i} & = & 1                                                                          \\
            \end{array} \right.
        \]
        \If $\locLengthLtFiftySix = 0$ we derive the following shorthand
        \[
            \locbytestringLengthBytesize \define (\wcpCtMax_{i + \rowOffsetCompareFiftyFive} + 1)
        \]
        And we impose
        \[
            \left\{ \begin{array}{lcl}
                \shfFlag         _{i + \rowOffsetCompareFiftyFive} & = & 1                                                                                              \\
                \shfArg          _{i + \rowOffsetCompareFiftyFive} & = & \llargeMO - \locbytestringLengthBytesize                                                       \\
                \resultColumn{1} _{i}                              & = & 1                                                                                              \\
                \resultColumn{2} _{i}                              & = & (\locBaseRlpPrefixLong + \locbytestringLengthBytesize) \cdot 256 ^{\llargeMO} + \locPaddedLimb \\
                \resultColumn{3} _{i}                              & = & 1                                                                                              \\
                \resultColumn{5} _{i}                              & = & 1 + \locbytestringLengthBytesize                                                               \\
            \end{array} \right.
        \]
        where we used the following shorthand
        \[
            \locPaddedLimb \define \shfPower _{i + \rowOffsetCompareFiftyFive} \cdot \locBytestringLength
        \]
\end{description}
