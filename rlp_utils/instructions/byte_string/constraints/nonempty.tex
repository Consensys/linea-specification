\[
    \boxed{\text{All constraints in this subsection assume }
    \left\{ \begin{array}{lcl}
        \isRlpUtilsMacro                  _{i} & = & 1 \\
        \rlpUtilsInstByteStringPrefixFlag _{i} & = & 1 \\
        \locByteStringIsNonempty               & = & 1 \\
    \end{array} \right.
    }
\]
\begin{description}
    \item[\underline{\underline{Setting \maxCt:}}]
        we impose $\maxCt _{i + 1} = \bytestringNonEmptyCtMax$
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetLengthIsOne)$:}} \underline{Comparing \locInputByteStringByteSize{} to $1$:}]
        we impose
        \[
            \wcpCallToEq {
                anchorRow = i                           ,
                relOffset = \rowOffsetLengthIsOne       ,
                argOneHi  = 0                           ,
                argOneLo  = \locInputByteStringByteSize ,
                argTwoLo  = 1                           ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locByteStringLengthIsOne            & \define & \res_{i + \rowOffsetLengthIsOne} \\
                \locByteStringLengthIsGreaterThanOne & \define & 1 - \locByteStringLengthIsOne  \\
            \end{array} \right.
        \]
\end{description}
We must now distinguish between the two associated subcases.
\begin{description}
    \item[\underline{\underline{Processing row $n^\circ(\rowOffsetCompareOneTwoEight)$:}}]
        we must distinguish between $\locByteStringLengthIsOne \equiv 0$ and $\locByteStringLengthIsOne \equiv 1$.
        \begin{description}
            \item[\underline{\underline{The \locByteStringLengthIsOne{} case:}}]
                \If $\locByteStringLengthIsOne = 1$ \Then
                \begin{description}
                    \item[\underline{Comparing \locInputByteStringFirstByte{} to $\rlprefixShortInt$:}]
                        we impose that
                        \[
                            \wcpCallToLt {
                                anchorRow = i                            ,
                                relOffset = \rowOffsetCompareOneTwoEight ,
                                argOneHi  = 0                            ,
                                argOneLo  = \locInputByteStringFirstByte ,
                                argTwoLo  = \rlprefixShortInt            ,
                            }
                        \]
                        and we derive the following shorthand
                        \[
                            \locByteStringFirstByteIsLtOneTwoEight \define \res_{i + \rowOffsetCompareOneTwoEight}
                        \]
                    \item[\underline{Justifying remaining predictions:}]
                        we impose
                        \begin{enumerate}
                            \item \If $\locByteStringFirstByteIsLtOneTwoEight = 1$ we impose
                                \[
                                    \left\{ \begin{array}{lcl}
                                        \locOutputRlpPrefixRequired & = & \false \\
                                        \locOutputRlpPrefix         & = & 0      \quad (\trash) \\
                                        \locOutputRlpPrefixByteSize & = & 0      \quad (\trash) \\
                                    \end{array} \right.
                                \]
                            \item \If $\locByteStringFirstByteIsLtOneTwoEight = 0$ we impose
                                \[
                                    \left\{ \begin{array}{lcl}
                                        \locOutputRlpPrefixRequired & = & \true                                               \\
                                        \locOutputRlpPrefix         & = & (\locBaseRlpPrefixShort + 1) \cdot 256 ^{\llargeMO} \\
                                        \locOutputRlpPrefixByteSize & = & 1                                                   \\
                                    \end{array} \right.
                                \]
                        \end{enumerate}
                \end{description}
            \item[\underline{\underline{The \locByteStringLengthIsGreaterThanOne{} case:}}]
                \If $\locByteStringLengthIsGreaterThanOne = 1$ \Then
                \begin{description}
                    \item[\underline{Comparing data length to $\fiftySix$:}]
                        we impose that
                        \[
                            \wcpCallToLt {
                                anchorRow = i                           ,
                                relOffset = \rowOffsetCompareFiftyFive  ,
                                argOneHi  = 0                           ,
                                argOneLo  = \locInputByteStringByteSize ,
                                argTwoLo  = \fiftySix                   ,
                            }
                        \]
                        and we derive the following shorthand
                        \[
                            \left\{ \begin{array}{lcl}
                                \locByteStringLengthIsLtFiftySix & \define & \res_{i + \rowOffsetCompareFiftyFive}            \\
                                \locByteStringLengthByteSize     & \define & (\wcpCtMax_{i + \rowOffsetCompareFiftyFive} + 1) \\
                            \end{array} \right.
                        \]
                    \item[\underline{Justifying remaining predictions:}]
                        we must again distinguish cases:
                        \begin{enumerate}
                            \item \If $\locByteStringLengthIsLtFiftySix = 1$ we impose
                                \[
                                    \left\{ \begin{array}{lcl}
                                        \locOutputRlpPrefixRequired & = & \true \\
                                        \locOutputRlpPrefix         & = &
                                        \left[ \begin{array}{cr}
                                            + & \locBaseRlpPrefixShort      \\
                                            + & \locInputByteStringByteSize \\
                                        \end{array} \right]
                                        \cdot 256 ^{\llargeMO}
                                        \\
                                        \locOutputRlpPrefixByteSize & = & 1 \\
                                    \end{array} \right.
                                \]
                            \item \If $\locByteStringLengthIsLtFiftySix = 0$ we derive the following shorthand
                                we impose
                                \[
                                    \left\{ \begin{array}{l}
                                        \getShiftingFactor {
                                            anchorRow    = i                                  ,
                                            relOffset    = \rowOffsetCompareFiftyFive         ,
                                            limbByteSize = 1 + \locByteStringLengthByteSize ,
                                        } \vspace{2mm} \\
                                        \locLeftShiftedByteSize \define \locInputByteStringByteSize \cdot \shfPower _{i + \rowOffsetCompareFiftyFive} \\
                                    \end{array} \right.
                                \]
                                and we conclude
                                \[
                                    \left\{ \begin{array}{lcl}
                                        \locOutputRlpPrefixRequired & = & \true \\
                                        \locOutputRlpPrefix         & = &
                                        \left[ \begin{array}{cr}
                                            + & \locBaseRlpPrefixLong          \\
                                            + & \locByteStringLengthByteSize \\
                                        \end{array} \right]
                                        \cdot 256 ^{\llargeMO}
                                        + \locLeftShiftedByteSize
                                        \\
                                        \locOutputRlpPrefixByteSize & = & 1 + \locByteStringLengthByteSize \\
                                    \end{array} \right.
                                \]
                                \saNote{}
                                The formula defining $\shfArg$ differs from that in
                                section~(\ref{rlp utils: instructions: data pricing: constraints}).
                                The reason for this discrepancy is that the the first (left aligned) byte of the current \rlp{} prefix is already occupied by a byte
                                (which essentially represents the "size in bytes of (the size in bytes of the byte string)").
                                In other words: the leading byte (of the $\llarge$ available bytes) is already taken up%
                                \footnote{by the size in bytes of the \rlp{} prefix representing the size in bytes of the size in bytes of the byte string \faSmileO{}.}.
                                One must therefore align the byte size ``one byte further down.''
                        \end{enumerate}
                \end{description}
            \end{description}
        \end{description}
