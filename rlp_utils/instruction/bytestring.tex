\[
    \boxed{\text{All constraints in this subsection assume } \isRlpUtilsMacro_{i} = 1 \et \INST_{i} = \inst{BYTESTRING}}
\]
We use the following shorthand:
\[
    \left\{ \begin{array}{lcl}
        \locIsList             & \define & \inputColumn{1}_{i} 
        \locBytestringLength   & \define & \inputColumn{2}_{i} 
        \locFirstByte          & \define & \inputColumn{3}_{i}                                                                    \\
        \locBaseRlpPrefixShort & \define & \rlprefixShortInt \cdot (1 - \locIsList) + \rlprefixShortList \cdot \locIsList \\
        \locBaseRlpPrefixLong  & \define & \rlprefixLongInt  \cdot (1 - \locIsList) + \rlprefixLongList  \cdot \locIsList \\
    \end{array} \right.
\]

\begin{description}
    \def\nRows{\rowOffsetNullString}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting null byte string:}]
        we impose that
        \[
            \wcpCallToIszero {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneLo  = \locBytestringLength   ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locNullBytestring    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locNullBytestring = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \maxCt           _{i+1} & = & \bytestringEmptyCtMax                         \\
                \resultColumn{1} _{i}   & = & 1                                             \\
                \resultColumn{2} _{i}   & = & \locBaseRlpPrefixShort \cdot 256 ^{\llargeMO} \\
                \resultColumn{5} _{i}   & = & 1                                             \\
            \end{array} \right.  
        \]

        \If $\locNullBytestring = 0$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \maxCt_{i+1}    & = & \bytestringNonEmptyCtMax \\
            \end{array} \right.
        \]

    \def\nRows{\rowOffsetLengthIsOne}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting byte string is one:}]
        we impose that
        \[
            \wcpCallToEq {
                anchorRow = i                    ,
                relOffset = \nRows               ,
                argOneLo  = \locBytestringLength ,
                argTwoLo  = 1                    ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthIsOne    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locLengthIsOne =1$:
    \def\nRows{\rowOffsetCompareOneTwoEight}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Comparing data to $\rlprefixShortInt$:}]
        we impose that
        \[
            \wcpCallToLeq {
                anchorRow = i                 ,
                relOffset = \nRows            ,
                argOneLo  = \locFirstByte     ,
                argTwoLo  = \rlprefixShortInt ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locByteIsLeqOneTwoEight    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locByteIsLeqOneTwoEight = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 0                \\
                \resultColumn{2} _{i} & = & 0 \quad (\trash) \\
                \resultColumn{5} _{i} & = & 0 \quad (\trash) \\
            \end{array} \right.
        \]

        \If $\locByteIsLeqOneTwoEight = 0$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 1                                                   \\
                \resultColumn{2} _{i} & = & (\locBaseRlpPrefixShort + 1) \cdot 256 ^{\llargeMO} \\
                \resultColumn{3} _{i} & = & 1                                                   \\
            \end{array} \right.
        \]

        \If $\locLengthIsOne = 0$:
    \def\nRows{\rowOffsetCompareFiftyFive}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Comparing data length to $\fiftySix$:}]
        we impose that
        \[
            \wcpCallToLt {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneLo  = \locBytestringLength   ,
                argTwoLo  = \fiftySix              ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthLtFiftySix  & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locLengthLtFiftySix = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 1                                                             \\
                \resultColumn{2} _{i} & = & (\locBaseRlpPrefixShort + \locBytestringLength_{i}) \cdot 256 ^{\llargeMO} \\
                \resultColumn{5} _{i} & = & 1                                                             \\
            \end{array} \right.
        \]

        \If $\locLengthLtFiftySix = 0$ we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locbytestringLengthBytesize  & \define & (\wcpCtMax_{i + \nRows} + 1) \\
            \end{array} \right.
        \]

        And we impose
        \[
            \left\{ \begin{array}{lcl}
                \shfFlag         _{i + \nRows} & = & 1                                                               \\
                \shfArg          _{i + \nRows} & = & \locBytestringLength                                            \\
                \shfValue        _{i + \nRows} & = & \llargeMO - \locbytestringLengthBytesize                        \\
                \resultColumn{1} _{i}          & = & 1                                                               \\
                \resultColumn{2} _{i}          & = & (\locBaseRlpPrefixLong + \locbytestringLengthBytesize) \cdot 256 ^{\llargeMO} + \shfRes _{i + \nRows} \\
                \resultColumn{5} _{i}          & = & 1 + \locbytestringLengthBytesize                                \\
            \end{array} \right.
        \]
\end{description}
