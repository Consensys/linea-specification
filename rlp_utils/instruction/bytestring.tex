\[
    \boxed{\text{All constraints in this subsection assume } \first_{i} = 1 \et \INST_{i} = \inst{BYTESTRING}}
\]
$\argOne$ represents the length of the byteString and $\argTwo$ represents the first byte of the byte string, if any.
We use the following shorthand:
         \[
            \left\{ \begin{array}{lcl}
                \res{4}_{i}             & \define & \locIsList \\
                \locBaseRlpPrefixShort  & \define & \rlprefixShortInt \cdot (1 - \locIsList) + \rlprefixShortList \cdot \locIsList \\
                \locBaseRlpPrefixLong   & \define & \rlprefixLongInt  \cdot (1 - \locIsList) + \rlprefixLongList  \cdot \locIsList \\
            \end{array} \right.
        \]

\begin{description}
\def\nRows{\rowOffsetNullString}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting null byte string:}]
        we impose that
        \[
            \wcpCallToIszero {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneHi  = \argOne                ,
                argOneLo  = 0                      ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locNullBytestring    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locNullBytestring = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \maxCt_{i}    & = & \bytestringEmptyCtMax \\
                \res{1}_{i}   & = & 0 \\
                \res{2}_{i}   & = & \locBaseRlpPrefixShort \cdot 256 ^{\llargeMO} \\
                \res{3}_{i}   & = & 1 \\
            \end{array} \right.
        \]

        \If $\locNullBytestring = 0$ we impose
         \[
            \left\{ \begin{array}{lcl}
                \maxCt_{i}    & = & \bytestringNonEmptyCtMax \\
            \end{array} \right.
        \]

\def\nRows{\rowOffsetLengthIsOne}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting null byte string:}]
        we impose that
        \[
            \wcpCallToEq {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneHi  = 0                      ,
                argOneLo  = \argOne                ,
                argTwoHi  = 0                      ,
                argTwoLo  = 1                      ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthIsOne    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

\If $\locLengthIsOne =1$:
\def\nRows{\rowOffsetCompareOneTwoEight}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Comparing data to $\rlprefixShortInt$:}]
        we impose that
        \[
            \wcpCallToLeq {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneHi  = 0                      ,
                argOneLo  = \argTwo                ,
                argTwoHi  = 0                      ,
                argTwoLo  = \rlprefixShortInt      ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locByteIsLeqOneTwoEight    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locByteIsLeqOneTwoEight = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \res{1}_{i}   & = & 1 \\
                \res{2}_{i}   & = & 0 \quad (\trash) \\
                \res{3}_{i}   & = & 0 \quad (\trash) \\
            \end{array} \right.
        \]

        \If $\locByteIsLeqOneTwoEight = 0$ we impose
         \[
            \left\{ \begin{array}{lcl}
                \res{1}_{i}   & = & 0 \\
                \res{2}_{i}   & = & (\locBaseRlpPrefixShort + 1) \cdot 256 ^{\llargeMO} \\
                \res{3}_{i}   & = & 1 \\
            \end{array} \right.
        \]

\If $\locLengthIsOne = 0$:
\def\nRows{\rowOffsetCompareFiftyFive}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Comparing data length to $\fiftySix$:}]
        we impose that
        \[
            \wcpCallToLt {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneHi  = 0                      ,
                argOneLo  = \argOne                ,
                argTwoHi  = 0                      ,
                argTwoLo  = \fiftySix              ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthLtFiftySix  & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locLengthLtFiftySix = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \res{1}_{i}   & = & 0 \\
                \res{2}_{i}   & = & (\locBaseRlpPrefixShort + \argOne_{i}) \cdot 256 ^{\llargeMO} \\
                \res{3}_{i}   & = & 1 \\
            \end{array} \right.
        \]

        \If $\locLengthLtFiftySix = 0$ we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locbytestringLengthBytesize  & \define & (\wcpCtMax_{i + \nRows} + 1) \\
            \end{array} \right.
        \]

        And we impose
         \[
            \left\{ \begin{array}{lcl}
                \shfFlag{i + \nRows}  & = & 1 \\
                \shfArg{i + \nRows}   & = & 8 \cdot (\llargeMO - \locbytestringLengthBytesize) \\
                \res{1}_{i}           & = & 0 \\
                \res{2}_{i}           & = & (\locBaseRlpPrefixLong + \locbytestringLengthBytesize) \cdot 256 ^{\llargeMO} + \shfRes{i + \nRows} \\
                \res{3}_{i}           & = & 1 + \locbytestringLengthBytesize \\
            \end{array} \right.
        \]