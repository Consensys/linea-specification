\[
    \boxed{\text{All constraints in this subsection assume } \first_{i} = 1 \et \INST_{i} = \inst{BYTESTRING}}
\]
$\argOne$ represents the length of the byteString and $\argTwo$ represents the first byte of the byte string, if any.
We use the following shorthand:
\[
    \left\{ \begin{array}{lcl}
        \resultColumn{4} _{i}  & \define & \locIsList                                                                     \\
        \locBaseRlpPrefixShort & \define & \rlprefixShortInt \cdot (1 - \locIsList) + \rlprefixShortList \cdot \locIsList \\
        \locBaseRlpPrefixLong  & \define & \rlprefixLongInt  \cdot (1 - \locIsList) + \rlprefixLongList  \cdot \locIsList \\
    \end{array} \right.
\]

\begin{description}
    \def\nRows{\rowOffsetNullString}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting null byte string:}]
        we impose that
        \[
            \wcpCallToIszero {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneHi  = \argOne                ,
                argOneLo  = 0                      ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locNullBytestring    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locNullBytestring = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \maxCt           _{i} & = & \bytestringEmptyCtMax                         \\
                \resultColumn{1} _{i} & = & 0                                             \\
                \resultColumn{2} _{i} & = & \locBaseRlpPrefixShort \cdot 256 ^{\llargeMO} \\
                \resultColumn{3} _{i} & = & 1                                             \\
            \end{array} \right.
        \]

        \If $\locNullBytestring = 0$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \maxCt_{i}    & = & \bytestringNonEmptyCtMax \\
            \end{array} \right.
        \]

    \def\nRows{\rowOffsetLengthIsOne}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting null byte string:}]
        we impose that
        \[
            \wcpCallToEq {
                anchorRow = i       ,
                relOffset = \nRows  ,
                argOneHi  = 0       ,
                argOneLo  = \argOne ,
                argTwoHi  = 0       ,
                argTwoLo  = 1       ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthIsOne    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locLengthIsOne =1$:
    \def\nRows{\rowOffsetCompareOneTwoEight}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Comparing data to $\rlprefixShortInt$:}]
        we impose that
        \[
            \wcpCallToLeq {
                anchorRow = i                 ,
                relOffset = \nRows            ,
                argOneHi  = 0                 ,
                argOneLo  = \argTwo           ,
                argTwoHi  = 0                 ,
                argTwoLo  = \rlprefixShortInt ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locByteIsLeqOneTwoEight    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locByteIsLeqOneTwoEight = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 1                \\
                \resultColumn{2} _{i} & = & 0 \quad (\trash) \\
                \resultColumn{3} _{i} & = & 0 \quad (\trash) \\
            \end{array} \right.
        \]

        \If $\locByteIsLeqOneTwoEight = 0$ we impose
        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 0                                                   \\
                \resultColumn{2} _{i} & = & (\locBaseRlpPrefixShort + 1) \cdot 256 ^{\llargeMO} \\
                \resultColumn{3} _{i} & = & 1                                                   \\
            \end{array} \right.
        \]

        \If $\locLengthIsOne = 0$:
    \def\nRows{\rowOffsetCompareFiftyFive}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Comparing data length to $\fiftySix$:}]
        we impose that
        \[
            \wcpCallToLt {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneHi  = 0                      ,
                argOneLo  = \argOne                ,
                argTwoHi  = 0                      ,
                argTwoLo  = \fiftySix              ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locLengthLtFiftySix  & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \]

        \If $\locLengthLtFiftySix = 1$ we impose

        \[
            \left\{ \begin{array}{lcl}
                \resultColumn{1} _{i} & = & 0                                                             \\
                \resultColumn{2} _{i} & = & (\locBaseRlpPrefixShort + \argOne_{i}) \cdot 256 ^{\llargeMO} \\
                \resultColumn{3} _{i} & = & 1                                                             \\
            \end{array} \right.
        \]

        \If $\locLengthLtFiftySix = 0$ we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locbytestringLengthBytesize  & \define & (\wcpCtMax_{i + \nRows} + 1) \\
            \end{array} \right.
        \]

        And we impose
        \[
            \left\{ \begin{array}{lcl}
                \shfFlag         _{i + \nRows} & = & 1                                                                                                     \\
                \shfArg          _{i + \nRows} & = & 8 \cdot (\llargeMO - \locbytestringLengthBytesize)                                                    \\
                \resultColumn{1} _{i}          & = & 0                                                                                                     \\
                \resultColumn{2} _{i}          & = & (\locBaseRlpPrefixLong + \locbytestringLengthBytesize) \cdot 256 ^{\llargeMO} + \shfRes _{i + \nRows} \\
                \resultColumn{3} _{i}          & = & 1 + \locbytestringLengthBytesize                                                                      \\
            \end{array} \right.
        \]
\end{description}
