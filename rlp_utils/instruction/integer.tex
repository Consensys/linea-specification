\[
    \boxed{\text{All constraints in this subsection assume } \isRlpUtilsMacro_{i} = 1 \et \INST_{i} = \inst{INTEGER} }
\]
We use the following shorthand:
\[
    \left\{ \begin{array}{lcl}
        \integerHi             & \define & \inputColumn{1}_{i} 
        \integerLo             & \define & \inputColumn{2}_{i} 
    \end{array} \right.
\]

We impose $\maxCt_{i+1} = \integerCtMax$.

\begin{description}
    \def\nRows{\rowOffsetHighZero}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting null high part:}]
        we impose that
        \[
            \wcpCallToGt {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneLo  = \integerHi             ,
                argTwoLo  = 0                      ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locBigInt    & \define & \res_{i + \nRows} \\
            \end{array} \right.
        \].


    \def\nRows{\rowOffsetSmallInt}\item[\underline{\underline{Processing row $n^\circ(\nRows)$:}} \underline{Detecting small integer:}]
        we impose that
        \[
            \wcpCallToLeq {
                anchorRow = i                      ,
                relOffset = \nRows                 ,
                argOneLo  = \integerLo             ,
                argTwoLo  = \oneTwoEight           ,
            }
        \]
        and we derive the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locSmallInt   & \define & (1 - \locBigInt) \cdot \res_{i + \nRows} \\
                \locTotalSize  & \define & \locBigInt \cdot (\llarge + (\wcpCtMax_{i + \rowOffsetHighZero} + 1) + (1 - \locBigInt) \cdot (\wcpCtMax_{i + \nRows} + 1) \\
                \locNBytes     & \define & \locBigInt \cdot (\wcpCtMax_{i + \rowOffsetHighZero} + 1) + (1 - \locBigInt) \cdot (\wcpCtMax_{i + \nRows} +1)\\
            \end{array} \right.
        \].
\end{description}

Finalization constraint:

We impose
\[
    \left\{ \begin{array}{lcl}
        \shfFlag          _{i + \nRows} & = & 1                                                                 \\
        \shfArg           _{i + \nRows} & = & \llarge - \locNBytes                                              \\
        \resultColumn {1} _{i}          & = & 1 - \locSmallInt                                                  \\
        \resultColumn {2} _{i}          & = & \rlprefixShortInt + \locTotalSize                                 \\
        \resultColumn {3} _{i}          & = & \locBigInt                                                        \\
        \resultColumn {4} _{i}          & = & \locPaddedLimb                                                    \\
        \resultColumn {5} _{i}          & = & \locNBytes                                                        \\
    \end{array} \right.
\]

 where we used the following shorthand
        \[
            \left\{ \begin{array}{lcl}
                \locPaddedLimb  & \define & \res_{i + \nRows} \cdot (\locBigInt \cdot \integerHi + (1 - \locBigInt) \cdot \integerLo) \\
            \end{array} \right.
        \]